{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/aero-dual/source/css/style.dark.styl","path":"css/style.dark.styl","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/css/style.light.styl","path":"css/style.light.styl","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/js/highlight.pack.js","path":"js/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/img/aero-dual-color-change.jpg","path":"img/aero-dual-color-change.jpg","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/img/aero-dual-thumbnail.jpg","path":"img/aero-dual-thumbnail.jpg","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/img/default-banner-dark.jpg","path":"img/default-banner-dark.jpg","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/img/default-banner-light.jpg","path":"img/default-banner-light.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/aero-dual/_config.yml","hash":"58c1996b62c994c4769e819a5204533d69f11124","modified":1533053048000},{"_id":"themes/aero-dual/README.md","hash":"b477f39f4cf49c6e91cc1d6a90dafb1571a945ab","modified":1529322880000},{"_id":"themes/aero-dual/LICENSE","hash":"d1f917294a5484d49c0ecf43a81ab6e2a5396f4a","modified":1529322880000},{"_id":"source/_drafts/hi.md","hash":"34322c0cda60452b5af9d1ff938b0d3ac9db33dd","modified":1533050426000},{"_id":"source/_posts/SpringCloudConfig实践.md","hash":"21a1a51420bb463ed7cde35b354a94e1eb936ffd","modified":1533465393000},{"_id":"source/_posts/脚踏实地-HashMap.md","hash":"fa8294c61e7e82c5e981d3ff59630d72df5ccc0d","modified":1533462857000},{"_id":"source/_posts/.DS_Store","hash":"52dcec80fbed64cc4623a6b9aac081ea44c64072","modified":1533461712000},{"_id":"themes/aero-dual/languages/en.yml","hash":"2c5c7c44a36d207c425b8033bf99bdcfa7dcd8d0","modified":1529322880000},{"_id":"themes/aero-dual/languages/zh-CN.yml","hash":"dbc362f1629511f77608bd4cc437a7e0dd2e8cc0","modified":1533053464000},{"_id":"themes/aero-dual/layout/archive.ejs","hash":"273dec29ccd9b596e305618b82e6ee4e930b3327","modified":1529322880000},{"_id":"themes/aero-dual/layout/index.ejs","hash":"43f88bc5d83aa7e791a8ef05af09d71f72d6f917","modified":1533058035000},{"_id":"themes/aero-dual/layout/layout.ejs","hash":"18550a2bff0e3a3556f54ac11f6b490d2683737c","modified":1529322880000},{"_id":"themes/aero-dual/layout/page.ejs","hash":"a9fa586eb3366949207921edd02eab07e7a2f0c0","modified":1533058249000},{"_id":"themes/aero-dual/layout/post.ejs","hash":"a9fa586eb3366949207921edd02eab07e7a2f0c0","modified":1529322880000},{"_id":"source/_posts/脚踏实地-HashMap/HashMap_Node_1_8.jpeg","hash":"fe2d7eb4ef44c404b47839f4a2f604a66d3d3e49","modified":1533393546000},{"_id":"source/_posts/脚踏实地-HashMap/HashMap_Node_1_7.jpeg","hash":"28554ce0c9a457524278ca185d3e67e016ac6955","modified":1533370255000},{"_id":"themes/aero-dual/layout/_partial/after-footer.ejs","hash":"f98091c7aace55d71c1ba458979e789edeecc029","modified":1529322880000},{"_id":"themes/aero-dual/layout/_partial/archive-entry.ejs","hash":"f3320090959299d42fd07289eab21259e8b1eb44","modified":1529322880000},{"_id":"themes/aero-dual/layout/_partial/footer.ejs","hash":"f6fd89878eae4f41b7289882cf9c5700a5057e3e","modified":1529322880000},{"_id":"themes/aero-dual/layout/_partial/google-analytics.ejs","hash":"d19d394eb45cde43504306c5dc377f044faf0a23","modified":1529322880000},{"_id":"themes/aero-dual/layout/_partial/header.ejs","hash":"b8f42af66a80705fc774f2cc9a8ae4c560b81bf1","modified":1529322880000},{"_id":"themes/aero-dual/layout/_partial/html-head.ejs","hash":"36ac5dbd80a4eefea2b49f7a0de25f97d6b16d9c","modified":1529322880000},{"_id":"themes/aero-dual/layout/_partial/index-entry.ejs","hash":"df1aaf8e4251668e5bb2a53e6eca6fae46e65887","modified":1533058000000},{"_id":"themes/aero-dual/layout/_partial/pagination.ejs","hash":"e70eda7f452724c083073342df3b897019656d13","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_base.styl","hash":"176ae298d70df9c063e6414c7723a434854e8bee","modified":1529322880000},{"_id":"themes/aero-dual/source/css/style.dark.styl","hash":"079289e71db062072ade0a64f2a4fa671a53c9b3","modified":1529322880000},{"_id":"themes/aero-dual/source/css/style.light.styl","hash":"5ef3cff44a3f0dc612811ca0d3e452f96a787b38","modified":1529322880000},{"_id":"themes/aero-dual/source/js/bootstrap.min.js","hash":"430a443d74830fe9be26efca431f448c1b3740f9","modified":1529322880000},{"_id":"themes/aero-dual/source/css/bootstrap.min.css","hash":"6527d8bf3e1e9368bab8c7b60f56bc01fa3afd68","modified":1529322880000},{"_id":"themes/aero-dual/source/js/highlight.pack.js","hash":"f4454691717eb6e4f26fddfd5ba14df824b44c41","modified":1529322880000},{"_id":"themes/aero-dual/layout/_partial/post/article.ejs","hash":"bab1cde99dea1e7f600202c64ff179b2fee224f1","modified":1533058755000},{"_id":"themes/aero-dual/layout/_partial/post/categories.ejs","hash":"da398995647f6fe549cc60003cbe193b39c07f8e","modified":1529322880000},{"_id":"themes/aero-dual/layout/_partial/post/tags.ejs","hash":"2ecd44bfa51b6c3c2343cc39038225d10e9775ca","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_helpers/mixins.styl","hash":"ebc6918703b60b1bc71ee879ef7970c881bba8b5","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_partial/archive-entry.styl","hash":"ed5fa62d499ac2f4af375ffabb6246be2bef07ad","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_partial/article.styl","hash":"1fa4af57699829f4280c428e01558bea55c5afec","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_partial/footer.styl","hash":"ff2b0419b7875860c391f454ec4f105192330fdf","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_partial/header.styl","hash":"122e8bddb4ba45752a6e8caa83d1d88c46af1220","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_partial/index-entry.styl","hash":"b78c87bec299215682ec6f56d22cd5c8d5a935f6","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_partial/pagination.styl","hash":"32efb7506e9c824f7e8132c8f4a216301334f8e1","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_typography/code.styl","hash":"c461f2fda5c88c363342ab07f5bd09346c506790","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_typography/highlight.dracula.styl","hash":"848d245175f97bf255add7a2a089193a3cfed229","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_typography/highlight.gruvbox-light.styl","hash":"0a8bbc4ad4718661e9292b71423c7fa7ddb613d5","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_typography/highlight.monikai-sublime.styl","hash":"6fa62d4ced718f52b85ea2d92d883ac0b57df35b","modified":1529322880000},{"_id":"themes/aero-dual/source/css/_typography/typo.css","hash":"2901fed191955827af9bca56e4b50dc9c06a8533","modified":1529322880000},{"_id":"themes/aero-dual/source/img/aero-dual-color-change.jpg","hash":"d9c779262e2e4d9f54e42e54d63c94b54294a4dc","modified":1529322880000},{"_id":"themes/aero-dual/source/img/aero-dual-thumbnail.jpg","hash":"939c91a321b1caf579262fab7d8837812e21b5a9","modified":1529322880000},{"_id":"themes/aero-dual/source/img/default-banner-dark.jpg","hash":"e15832861cc6e5d55d08fbbe9d1cd472fe1a876e","modified":1529322880000},{"_id":"themes/aero-dual/source/img/default-banner-light.jpg","hash":"df4daccf84205e76708fc5e703dc2476f59a9d9d","modified":1529322880000}],"Category":[{"name":"SpringCloud","_id":"cjkgpmvjv00027lcgyqx2ewoy"},{"name":"脚踏实地","_id":"cjkgpmvkb00097lcgyrwttnhg"}],"Data":[],"Page":[],"Post":[{"title":"hi","_content":"","source":"_drafts/hi.md","raw":"---\ntitle: hi\ntags:\n---\n","slug":"hi","published":0,"date":"2018-07-31T15:20:26.000Z","updated":"2018-07-31T15:20:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkgpmvjm00007lcgechdc7sq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"SpringCloudConfig实践","date":"2018-08-05T09:54:12.000Z","_content":"\n<i>一些使用SpringCloudConfig的小技巧</i>\n\n<!-- more -->\n\n## 为啥要用Spring Cloud Config\nSpring  Cloud Config可以提供配置文件的区分profile，区分application，区分version管理，减少部署复杂度。这里只考虑以git仓库作为配置文件载体的情况。\n\n## 实践中遇到的问题\n先引用一段文档\n\n>The server is a Spring Boot application so you can run it from your IDE instead if you prefer (the main class is ConfigServerApplication). Then try out a client:\n\n\n```\n$ curl localhost:8888/foo/development\n\n{\"name\":\"development\",\"label\":\"master\",\"propertySources\":[\n  {\"name\":\"https://github.com/scratches/config-repo/foo-development.properties\",\"source\":{\"bar\":\"spam\"}},\n  {\"name\":\"https://github.com/scratches/config-repo/foo.properties\",\"source\":{\"foo\":\"bar\"}}\n\n]}\n```\n\n>The default strategy for locating property sources is to clone a git repository (at spring.cloud.config.server.git.uri) and use it to initialize a mini SpringApplication. The mini-application’s Environment is used to enumerate property sources and publish them via a JSON endpoint.\n\n```\nThe HTTP service has resources in the form:\n\n/{application}/{profile}[/{label}]\n\n/{application}-{profile}.yml\n\n/{label}/{application}-{profile}.yml\n\n/{application}-{profile}.properties\n\n/{label}/{application}-{profile}.properties\n\n```\n\n上面文档的大致说明了，通过ConfigServer获取配置的Http请求方式，但并没有说明在存储的yml文件的命名方式和存储方式。事实上，在仓库中存储的文件命名可以遵循{application}-{profile}.yml的命名方式，就跟在resourses文件夹里的一样。上面http请求中的label参数可以是git branch,git tag，那种都可以，也就是区分版本实际上使用的是git进行版本控制。\n\n#### 问题就来了：\n\n有两个application,clientA与clientB，想要两个application共享同一个config.yml文件\n\nconfig.yml\n\n```\nuser.name: ln\n\n```\n## 共享yml文件\n在共享同一yml文件之前还有一个问题要先解决，就是如何加载多个yml配置文件。\n\n可以通过spring.profiles.include 来完成。\n\n例如：\n\n在git仓库中有\n\n```\n|- clientA-local.yml\n|- clientA-user.yml\n```\n\nclientA-local.yml\n\n```\nspring.profiles.include: [\"user\"]\n```\nclientA-user.yml\n\n```\nuser.name: ln\n```\n按照以上配置时，再请求 http://configServer/clientA/local/，就可以发现clientA-user.yml中的配置已经加载进来了。具体的原理就是通过建立多个profile再通过spring.profiles.include整合配置。\n\n回到共享config的问题。\n\n我在翻阅了SpringCloudConfigServer的源码之后发现了神奇的东西。在org.springframework.cloud.config.server.environment.NativeEnvironmentRepository中有以下代码：\n\n```\n@ConfigurationProperties(\"spring.cloud.config.server.native\")public class NativeEnvironmentRepository implements EnvironmentRepository, SearchPathLocator, Ordered {\n\nprivate String[] getArgs(String application, String profile, String label) {\n    List list = new ArrayList();\n    String config = application;\n    if (!config.startsWith(\"application\")) {\n        config = \"application,\" + config;\n    }    \n    list.add(\"--spring.config.name=\" + config);    \n    list.add(\"--spring.cloud.bootstrap.enabled=false\");\n    list.add(\"--encrypt.failOnError=\" + this.failOnError);\n    list.add(\"--spring.config.location=\" +            StringUtils.arrayToCommaDelimitedString(getLocations(application, profile,         label).getLocations()));\n    return list.toArray(new String[0]);}\n\n}\n```\n\nNativeEnvironmentRepository是用于查询和筛选配置文件的类，其中最重要的方法是findOne,findOne中调用getArgs来获取查询和筛选参数。其中最重要的是这一句：\n\n```\n if (!config.startsWith(\"application\")) {     \n    config = \"application,\" + config;\n }    \n```\n如果传递的config没有以application开头的话，那就把application加进去。最终的结果便是application-{profile}.yml中的配置可以被{application}-{another-profile}.yml中通过spring.profiles.include=[{profile}]加载进去。\n\n例如：\n\n在git仓库中有\n\n```\n|- clientA-local.yml\n|- clientA-user.yml\n```\n\nclientA-local.yml\n\n```\nspring.profiles.include: [\"user\"]\napplication-user.yml\nuser.name: ln\n```\n\n按照以上配置时，再请求 http://configServer/clientA/local/。\n\n可以发现application-user.yml中的配置已经加载进来了。\n\n## 仓库整理的问题\n上面基本解决了很多问题，因为在实际只用时，同一个环境的数据库配置，各种签名秘钥的配置都是相同的，减少了重复写配置的问题。但时间一长又出现了另一个问题，就是仓库里太乱了。\n\n例如：\n\n```\n|- clientA-local.yml\n|- clientA-prod.yml\n|- clientB-local.yml\n|- clientB-prod.yml\n|- application-user.yml\n\n```\n理想中的形式应该是这样的：\n\n```\n|- clientA\n\n    |- clientA-local.yml\n\n    |- clientA-prod.yml\n\n|- clientB\n\n    |- clientB-local.yml\n\n    |- clientB-prod.yml\n\n|- application-user.yml\n\n```\n\n但是如果直接把形式改掉会发现找不到配置。解决方式如下：\n\n在configServer的配置中加入：\n\n```\nspring.cloud.config.server.git.search-paths: '{application}/{profile},{application}'\n```\n\n这样的话，请求 http://configServer/clientA/local/ 会搜索 / 目录、/clientA 目录、 /clientA/local 目录下的配置，扩大了配置检索的范围。\n\n解决了这个问题，SpringCloudConfig使用起来就比较开心了。\n\n## Demo\nApplication\n\nhttps://github.com/guoyxln/SpringCloudConfigDemo\n\n配置仓库\n\nhttps://github.com/guoyxln/SpringCloudConfigDemoRepository\n\n使用的时候把config/src/resources/application.yml中的git username 和 password 换成自己的github账号密码就好了。\n\nconfig-client 提供了个简单的name接口用于显示从配置中读取的name。可以试一下。\n\n","source":"_posts/SpringCloudConfig实践.md","raw":"---\ntitle: SpringCloudConfig实践\ndate: 2018-08-05 17:54:12\ntags:\n- SpringCloud\n- SpringCloudConfig\ncategories:\n- SpringCloud\n\n---\n\n<i>一些使用SpringCloudConfig的小技巧</i>\n\n<!-- more -->\n\n## 为啥要用Spring Cloud Config\nSpring  Cloud Config可以提供配置文件的区分profile，区分application，区分version管理，减少部署复杂度。这里只考虑以git仓库作为配置文件载体的情况。\n\n## 实践中遇到的问题\n先引用一段文档\n\n>The server is a Spring Boot application so you can run it from your IDE instead if you prefer (the main class is ConfigServerApplication). Then try out a client:\n\n\n```\n$ curl localhost:8888/foo/development\n\n{\"name\":\"development\",\"label\":\"master\",\"propertySources\":[\n  {\"name\":\"https://github.com/scratches/config-repo/foo-development.properties\",\"source\":{\"bar\":\"spam\"}},\n  {\"name\":\"https://github.com/scratches/config-repo/foo.properties\",\"source\":{\"foo\":\"bar\"}}\n\n]}\n```\n\n>The default strategy for locating property sources is to clone a git repository (at spring.cloud.config.server.git.uri) and use it to initialize a mini SpringApplication. The mini-application’s Environment is used to enumerate property sources and publish them via a JSON endpoint.\n\n```\nThe HTTP service has resources in the form:\n\n/{application}/{profile}[/{label}]\n\n/{application}-{profile}.yml\n\n/{label}/{application}-{profile}.yml\n\n/{application}-{profile}.properties\n\n/{label}/{application}-{profile}.properties\n\n```\n\n上面文档的大致说明了，通过ConfigServer获取配置的Http请求方式，但并没有说明在存储的yml文件的命名方式和存储方式。事实上，在仓库中存储的文件命名可以遵循{application}-{profile}.yml的命名方式，就跟在resourses文件夹里的一样。上面http请求中的label参数可以是git branch,git tag，那种都可以，也就是区分版本实际上使用的是git进行版本控制。\n\n#### 问题就来了：\n\n有两个application,clientA与clientB，想要两个application共享同一个config.yml文件\n\nconfig.yml\n\n```\nuser.name: ln\n\n```\n## 共享yml文件\n在共享同一yml文件之前还有一个问题要先解决，就是如何加载多个yml配置文件。\n\n可以通过spring.profiles.include 来完成。\n\n例如：\n\n在git仓库中有\n\n```\n|- clientA-local.yml\n|- clientA-user.yml\n```\n\nclientA-local.yml\n\n```\nspring.profiles.include: [\"user\"]\n```\nclientA-user.yml\n\n```\nuser.name: ln\n```\n按照以上配置时，再请求 http://configServer/clientA/local/，就可以发现clientA-user.yml中的配置已经加载进来了。具体的原理就是通过建立多个profile再通过spring.profiles.include整合配置。\n\n回到共享config的问题。\n\n我在翻阅了SpringCloudConfigServer的源码之后发现了神奇的东西。在org.springframework.cloud.config.server.environment.NativeEnvironmentRepository中有以下代码：\n\n```\n@ConfigurationProperties(\"spring.cloud.config.server.native\")public class NativeEnvironmentRepository implements EnvironmentRepository, SearchPathLocator, Ordered {\n\nprivate String[] getArgs(String application, String profile, String label) {\n    List list = new ArrayList();\n    String config = application;\n    if (!config.startsWith(\"application\")) {\n        config = \"application,\" + config;\n    }    \n    list.add(\"--spring.config.name=\" + config);    \n    list.add(\"--spring.cloud.bootstrap.enabled=false\");\n    list.add(\"--encrypt.failOnError=\" + this.failOnError);\n    list.add(\"--spring.config.location=\" +            StringUtils.arrayToCommaDelimitedString(getLocations(application, profile,         label).getLocations()));\n    return list.toArray(new String[0]);}\n\n}\n```\n\nNativeEnvironmentRepository是用于查询和筛选配置文件的类，其中最重要的方法是findOne,findOne中调用getArgs来获取查询和筛选参数。其中最重要的是这一句：\n\n```\n if (!config.startsWith(\"application\")) {     \n    config = \"application,\" + config;\n }    \n```\n如果传递的config没有以application开头的话，那就把application加进去。最终的结果便是application-{profile}.yml中的配置可以被{application}-{another-profile}.yml中通过spring.profiles.include=[{profile}]加载进去。\n\n例如：\n\n在git仓库中有\n\n```\n|- clientA-local.yml\n|- clientA-user.yml\n```\n\nclientA-local.yml\n\n```\nspring.profiles.include: [\"user\"]\napplication-user.yml\nuser.name: ln\n```\n\n按照以上配置时，再请求 http://configServer/clientA/local/。\n\n可以发现application-user.yml中的配置已经加载进来了。\n\n## 仓库整理的问题\n上面基本解决了很多问题，因为在实际只用时，同一个环境的数据库配置，各种签名秘钥的配置都是相同的，减少了重复写配置的问题。但时间一长又出现了另一个问题，就是仓库里太乱了。\n\n例如：\n\n```\n|- clientA-local.yml\n|- clientA-prod.yml\n|- clientB-local.yml\n|- clientB-prod.yml\n|- application-user.yml\n\n```\n理想中的形式应该是这样的：\n\n```\n|- clientA\n\n    |- clientA-local.yml\n\n    |- clientA-prod.yml\n\n|- clientB\n\n    |- clientB-local.yml\n\n    |- clientB-prod.yml\n\n|- application-user.yml\n\n```\n\n但是如果直接把形式改掉会发现找不到配置。解决方式如下：\n\n在configServer的配置中加入：\n\n```\nspring.cloud.config.server.git.search-paths: '{application}/{profile},{application}'\n```\n\n这样的话，请求 http://configServer/clientA/local/ 会搜索 / 目录、/clientA 目录、 /clientA/local 目录下的配置，扩大了配置检索的范围。\n\n解决了这个问题，SpringCloudConfig使用起来就比较开心了。\n\n## Demo\nApplication\n\nhttps://github.com/guoyxln/SpringCloudConfigDemo\n\n配置仓库\n\nhttps://github.com/guoyxln/SpringCloudConfigDemoRepository\n\n使用的时候把config/src/resources/application.yml中的git username 和 password 换成自己的github账号密码就好了。\n\nconfig-client 提供了个简单的name接口用于显示从配置中读取的name。可以试一下。\n\n","slug":"SpringCloudConfig实践","published":1,"updated":"2018-08-05T10:36:33.000Z","_id":"cjkgpmvjs00017lcgsyrwn7x5","comments":1,"layout":"post","photos":[],"link":"","content":"<p><i>一些使用SpringCloudConfig的小技巧</i></p>\n<a id=\"more\"></a>\n<h2 id=\"为啥要用Spring-Cloud-Config\"><a href=\"#为啥要用Spring-Cloud-Config\" class=\"headerlink\" title=\"为啥要用Spring Cloud Config\"></a>为啥要用Spring Cloud Config</h2><p>Spring  Cloud Config可以提供配置文件的区分profile，区分application，区分version管理，减少部署复杂度。这里只考虑以git仓库作为配置文件载体的情况。</p>\n<h2 id=\"实践中遇到的问题\"><a href=\"#实践中遇到的问题\" class=\"headerlink\" title=\"实践中遇到的问题\"></a>实践中遇到的问题</h2><p>先引用一段文档</p>\n<blockquote>\n<p>The server is a Spring Boot application so you can run it from your IDE instead if you prefer (the main class is ConfigServerApplication). Then try out a client:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl localhost:8888/foo/development</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;development&quot;,&quot;label&quot;:&quot;master&quot;,&quot;propertySources&quot;:[</span><br><span class=\"line\">  &#123;&quot;name&quot;:&quot;https://github.com/scratches/config-repo/foo-development.properties&quot;,&quot;source&quot;:&#123;&quot;bar&quot;:&quot;spam&quot;&#125;&#125;,</span><br><span class=\"line\">  &#123;&quot;name&quot;:&quot;https://github.com/scratches/config-repo/foo.properties&quot;,&quot;source&quot;:&#123;&quot;foo&quot;:&quot;bar&quot;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">]&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The default strategy for locating property sources is to clone a git repository (at spring.cloud.config.server.git.uri) and use it to initialize a mini SpringApplication. The mini-application’s Environment is used to enumerate property sources and publish them via a JSON endpoint.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The HTTP service has resources in the form:</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure>\n<p>上面文档的大致说明了，通过ConfigServer获取配置的Http请求方式，但并没有说明在存储的yml文件的命名方式和存储方式。事实上，在仓库中存储的文件命名可以遵循{application}-{profile}.yml的命名方式，就跟在resourses文件夹里的一样。上面http请求中的label参数可以是git branch,git tag，那种都可以，也就是区分版本实际上使用的是git进行版本控制。</p>\n<h4 id=\"问题就来了：\"><a href=\"#问题就来了：\" class=\"headerlink\" title=\"问题就来了：\"></a>问题就来了：</h4><p>有两个application,clientA与clientB，想要两个application共享同一个config.yml文件</p>\n<p>config.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user.name: ln</span><br></pre></td></tr></table></figure>\n<h2 id=\"共享yml文件\"><a href=\"#共享yml文件\" class=\"headerlink\" title=\"共享yml文件\"></a>共享yml文件</h2><p>在共享同一yml文件之前还有一个问题要先解决，就是如何加载多个yml配置文件。</p>\n<p>可以通过spring.profiles.include 来完成。</p>\n<p>例如：</p>\n<p>在git仓库中有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|- clientA-local.yml</span><br><span class=\"line\">|- clientA-user.yml</span><br></pre></td></tr></table></figure>\n<p>clientA-local.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.profiles.include: [&quot;user&quot;]</span><br></pre></td></tr></table></figure>\n<p>clientA-user.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user.name: ln</span><br></pre></td></tr></table></figure>\n<p>按照以上配置时，再请求 <a href=\"http://configServer/clientA/local/，就可以发现clientA-user.yml中的配置已经加载进来了。具体的原理就是通过建立多个profile再通过spring.profiles.include整合配置。\" target=\"_blank\" rel=\"noopener\">http://configServer/clientA/local/，就可以发现clientA-user.yml中的配置已经加载进来了。具体的原理就是通过建立多个profile再通过spring.profiles.include整合配置。</a></p>\n<p>回到共享config的问题。</p>\n<p>我在翻阅了SpringCloudConfigServer的源码之后发现了神奇的东西。在org.springframework.cloud.config.server.environment.NativeEnvironmentRepository中有以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ConfigurationProperties(&quot;spring.cloud.config.server.native&quot;)public class NativeEnvironmentRepository implements EnvironmentRepository, SearchPathLocator, Ordered &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">private String[] getArgs(String application, String profile, String label) &#123;</span><br><span class=\"line\">    List list = new ArrayList();</span><br><span class=\"line\">    String config = application;</span><br><span class=\"line\">    if (!config.startsWith(&quot;application&quot;)) &#123;</span><br><span class=\"line\">        config = &quot;application,&quot; + config;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    list.add(&quot;--spring.config.name=&quot; + config);    </span><br><span class=\"line\">    list.add(&quot;--spring.cloud.bootstrap.enabled=false&quot;);</span><br><span class=\"line\">    list.add(&quot;--encrypt.failOnError=&quot; + this.failOnError);</span><br><span class=\"line\">    list.add(&quot;--spring.config.location=&quot; +            StringUtils.arrayToCommaDelimitedString(getLocations(application, profile,         label).getLocations()));</span><br><span class=\"line\">    return list.toArray(new String[0]);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NativeEnvironmentRepository是用于查询和筛选配置文件的类，其中最重要的方法是findOne,findOne中调用getArgs来获取查询和筛选参数。其中最重要的是这一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!config.startsWith(&quot;application&quot;)) &#123;     </span><br><span class=\"line\">   config = &quot;application,&quot; + config;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果传递的config没有以application开头的话，那就把application加进去。最终的结果便是application-{profile}.yml中的配置可以被{application}-{another-profile}.yml中通过spring.profiles.include=[{profile}]加载进去。</p>\n<p>例如：</p>\n<p>在git仓库中有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|- clientA-local.yml</span><br><span class=\"line\">|- clientA-user.yml</span><br></pre></td></tr></table></figure>\n<p>clientA-local.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.profiles.include: [&quot;user&quot;]</span><br><span class=\"line\">application-user.yml</span><br><span class=\"line\">user.name: ln</span><br></pre></td></tr></table></figure>\n<p>按照以上配置时，再请求 <a href=\"http://configServer/clientA/local/。\" target=\"_blank\" rel=\"noopener\">http://configServer/clientA/local/。</a></p>\n<p>可以发现application-user.yml中的配置已经加载进来了。</p>\n<h2 id=\"仓库整理的问题\"><a href=\"#仓库整理的问题\" class=\"headerlink\" title=\"仓库整理的问题\"></a>仓库整理的问题</h2><p>上面基本解决了很多问题，因为在实际只用时，同一个环境的数据库配置，各种签名秘钥的配置都是相同的，减少了重复写配置的问题。但时间一长又出现了另一个问题，就是仓库里太乱了。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|- clientA-local.yml</span><br><span class=\"line\">|- clientA-prod.yml</span><br><span class=\"line\">|- clientB-local.yml</span><br><span class=\"line\">|- clientB-prod.yml</span><br><span class=\"line\">|- application-user.yml</span><br></pre></td></tr></table></figure>\n<p>理想中的形式应该是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|- clientA</span><br><span class=\"line\"></span><br><span class=\"line\">    |- clientA-local.yml</span><br><span class=\"line\"></span><br><span class=\"line\">    |- clientA-prod.yml</span><br><span class=\"line\"></span><br><span class=\"line\">|- clientB</span><br><span class=\"line\"></span><br><span class=\"line\">    |- clientB-local.yml</span><br><span class=\"line\"></span><br><span class=\"line\">    |- clientB-prod.yml</span><br><span class=\"line\"></span><br><span class=\"line\">|- application-user.yml</span><br></pre></td></tr></table></figure>\n<p>但是如果直接把形式改掉会发现找不到配置。解决方式如下：</p>\n<p>在configServer的配置中加入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.cloud.config.server.git.search-paths: &apos;&#123;application&#125;/&#123;profile&#125;,&#123;application&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p>这样的话，请求 <a href=\"http://configServer/clientA/local/\" target=\"_blank\" rel=\"noopener\">http://configServer/clientA/local/</a> 会搜索 / 目录、/clientA 目录、 /clientA/local 目录下的配置，扩大了配置检索的范围。</p>\n<p>解决了这个问题，SpringCloudConfig使用起来就比较开心了。</p>\n<h2 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h2><p>Application</p>\n<p><a href=\"https://github.com/guoyxln/SpringCloudConfigDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/guoyxln/SpringCloudConfigDemo</a></p>\n<p>配置仓库</p>\n<p><a href=\"https://github.com/guoyxln/SpringCloudConfigDemoRepository\" target=\"_blank\" rel=\"noopener\">https://github.com/guoyxln/SpringCloudConfigDemoRepository</a></p>\n<p>使用的时候把config/src/resources/application.yml中的git username 和 password 换成自己的github账号密码就好了。</p>\n<p>config-client 提供了个简单的name接口用于显示从配置中读取的name。可以试一下。</p>\n","site":{"data":{}},"excerpt":"<p><i>一些使用SpringCloudConfig的小技巧</i></p>","more":"<h2 id=\"为啥要用Spring-Cloud-Config\"><a href=\"#为啥要用Spring-Cloud-Config\" class=\"headerlink\" title=\"为啥要用Spring Cloud Config\"></a>为啥要用Spring Cloud Config</h2><p>Spring  Cloud Config可以提供配置文件的区分profile，区分application，区分version管理，减少部署复杂度。这里只考虑以git仓库作为配置文件载体的情况。</p>\n<h2 id=\"实践中遇到的问题\"><a href=\"#实践中遇到的问题\" class=\"headerlink\" title=\"实践中遇到的问题\"></a>实践中遇到的问题</h2><p>先引用一段文档</p>\n<blockquote>\n<p>The server is a Spring Boot application so you can run it from your IDE instead if you prefer (the main class is ConfigServerApplication). Then try out a client:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl localhost:8888/foo/development</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;development&quot;,&quot;label&quot;:&quot;master&quot;,&quot;propertySources&quot;:[</span><br><span class=\"line\">  &#123;&quot;name&quot;:&quot;https://github.com/scratches/config-repo/foo-development.properties&quot;,&quot;source&quot;:&#123;&quot;bar&quot;:&quot;spam&quot;&#125;&#125;,</span><br><span class=\"line\">  &#123;&quot;name&quot;:&quot;https://github.com/scratches/config-repo/foo.properties&quot;,&quot;source&quot;:&#123;&quot;foo&quot;:&quot;bar&quot;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">]&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The default strategy for locating property sources is to clone a git repository (at spring.cloud.config.server.git.uri) and use it to initialize a mini SpringApplication. The mini-application’s Environment is used to enumerate property sources and publish them via a JSON endpoint.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The HTTP service has resources in the form:</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure>\n<p>上面文档的大致说明了，通过ConfigServer获取配置的Http请求方式，但并没有说明在存储的yml文件的命名方式和存储方式。事实上，在仓库中存储的文件命名可以遵循{application}-{profile}.yml的命名方式，就跟在resourses文件夹里的一样。上面http请求中的label参数可以是git branch,git tag，那种都可以，也就是区分版本实际上使用的是git进行版本控制。</p>\n<h4 id=\"问题就来了：\"><a href=\"#问题就来了：\" class=\"headerlink\" title=\"问题就来了：\"></a>问题就来了：</h4><p>有两个application,clientA与clientB，想要两个application共享同一个config.yml文件</p>\n<p>config.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user.name: ln</span><br></pre></td></tr></table></figure>\n<h2 id=\"共享yml文件\"><a href=\"#共享yml文件\" class=\"headerlink\" title=\"共享yml文件\"></a>共享yml文件</h2><p>在共享同一yml文件之前还有一个问题要先解决，就是如何加载多个yml配置文件。</p>\n<p>可以通过spring.profiles.include 来完成。</p>\n<p>例如：</p>\n<p>在git仓库中有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|- clientA-local.yml</span><br><span class=\"line\">|- clientA-user.yml</span><br></pre></td></tr></table></figure>\n<p>clientA-local.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.profiles.include: [&quot;user&quot;]</span><br></pre></td></tr></table></figure>\n<p>clientA-user.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user.name: ln</span><br></pre></td></tr></table></figure>\n<p>按照以上配置时，再请求 <a href=\"http://configServer/clientA/local/，就可以发现clientA-user.yml中的配置已经加载进来了。具体的原理就是通过建立多个profile再通过spring.profiles.include整合配置。\" target=\"_blank\" rel=\"noopener\">http://configServer/clientA/local/，就可以发现clientA-user.yml中的配置已经加载进来了。具体的原理就是通过建立多个profile再通过spring.profiles.include整合配置。</a></p>\n<p>回到共享config的问题。</p>\n<p>我在翻阅了SpringCloudConfigServer的源码之后发现了神奇的东西。在org.springframework.cloud.config.server.environment.NativeEnvironmentRepository中有以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ConfigurationProperties(&quot;spring.cloud.config.server.native&quot;)public class NativeEnvironmentRepository implements EnvironmentRepository, SearchPathLocator, Ordered &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">private String[] getArgs(String application, String profile, String label) &#123;</span><br><span class=\"line\">    List list = new ArrayList();</span><br><span class=\"line\">    String config = application;</span><br><span class=\"line\">    if (!config.startsWith(&quot;application&quot;)) &#123;</span><br><span class=\"line\">        config = &quot;application,&quot; + config;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    list.add(&quot;--spring.config.name=&quot; + config);    </span><br><span class=\"line\">    list.add(&quot;--spring.cloud.bootstrap.enabled=false&quot;);</span><br><span class=\"line\">    list.add(&quot;--encrypt.failOnError=&quot; + this.failOnError);</span><br><span class=\"line\">    list.add(&quot;--spring.config.location=&quot; +            StringUtils.arrayToCommaDelimitedString(getLocations(application, profile,         label).getLocations()));</span><br><span class=\"line\">    return list.toArray(new String[0]);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NativeEnvironmentRepository是用于查询和筛选配置文件的类，其中最重要的方法是findOne,findOne中调用getArgs来获取查询和筛选参数。其中最重要的是这一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!config.startsWith(&quot;application&quot;)) &#123;     </span><br><span class=\"line\">   config = &quot;application,&quot; + config;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果传递的config没有以application开头的话，那就把application加进去。最终的结果便是application-{profile}.yml中的配置可以被{application}-{another-profile}.yml中通过spring.profiles.include=[{profile}]加载进去。</p>\n<p>例如：</p>\n<p>在git仓库中有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|- clientA-local.yml</span><br><span class=\"line\">|- clientA-user.yml</span><br></pre></td></tr></table></figure>\n<p>clientA-local.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.profiles.include: [&quot;user&quot;]</span><br><span class=\"line\">application-user.yml</span><br><span class=\"line\">user.name: ln</span><br></pre></td></tr></table></figure>\n<p>按照以上配置时，再请求 <a href=\"http://configServer/clientA/local/。\" target=\"_blank\" rel=\"noopener\">http://configServer/clientA/local/。</a></p>\n<p>可以发现application-user.yml中的配置已经加载进来了。</p>\n<h2 id=\"仓库整理的问题\"><a href=\"#仓库整理的问题\" class=\"headerlink\" title=\"仓库整理的问题\"></a>仓库整理的问题</h2><p>上面基本解决了很多问题，因为在实际只用时，同一个环境的数据库配置，各种签名秘钥的配置都是相同的，减少了重复写配置的问题。但时间一长又出现了另一个问题，就是仓库里太乱了。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|- clientA-local.yml</span><br><span class=\"line\">|- clientA-prod.yml</span><br><span class=\"line\">|- clientB-local.yml</span><br><span class=\"line\">|- clientB-prod.yml</span><br><span class=\"line\">|- application-user.yml</span><br></pre></td></tr></table></figure>\n<p>理想中的形式应该是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|- clientA</span><br><span class=\"line\"></span><br><span class=\"line\">    |- clientA-local.yml</span><br><span class=\"line\"></span><br><span class=\"line\">    |- clientA-prod.yml</span><br><span class=\"line\"></span><br><span class=\"line\">|- clientB</span><br><span class=\"line\"></span><br><span class=\"line\">    |- clientB-local.yml</span><br><span class=\"line\"></span><br><span class=\"line\">    |- clientB-prod.yml</span><br><span class=\"line\"></span><br><span class=\"line\">|- application-user.yml</span><br></pre></td></tr></table></figure>\n<p>但是如果直接把形式改掉会发现找不到配置。解决方式如下：</p>\n<p>在configServer的配置中加入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.cloud.config.server.git.search-paths: &apos;&#123;application&#125;/&#123;profile&#125;,&#123;application&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p>这样的话，请求 <a href=\"http://configServer/clientA/local/\" target=\"_blank\" rel=\"noopener\">http://configServer/clientA/local/</a> 会搜索 / 目录、/clientA 目录、 /clientA/local 目录下的配置，扩大了配置检索的范围。</p>\n<p>解决了这个问题，SpringCloudConfig使用起来就比较开心了。</p>\n<h2 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h2><p>Application</p>\n<p><a href=\"https://github.com/guoyxln/SpringCloudConfigDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/guoyxln/SpringCloudConfigDemo</a></p>\n<p>配置仓库</p>\n<p><a href=\"https://github.com/guoyxln/SpringCloudConfigDemoRepository\" target=\"_blank\" rel=\"noopener\">https://github.com/guoyxln/SpringCloudConfigDemoRepository</a></p>\n<p>使用的时候把config/src/resources/application.yml中的git username 和 password 换成自己的github账号密码就好了。</p>\n<p>config-client 提供了个简单的name接口用于显示从配置中读取的name。可以试一下。</p>"},{"title":"脚踏实地-HashMap","date":"2018-07-31T16:15:06.000Z","_content":"\n<i>带着问题分析HashMap源码，包括：如何初始化，基础操作的实现，扩容，遍历等。</i>\n\n<!-- more -->\n\n## 前言\n\n\n\n前些日子找工作面试的时候暴露了我的一个问题，有些问题知其然而不知其所以然。例如：我们都知道HashMap不是线程安全的，那么多线程中使用HashMap会产生什么问题？ConcurrentHashMap是线程安全的，为了线程安全做了哪些牺牲，有什么局限性？无法回答这些问题的原因是，没有看源码或是看源码时没有进行思考，所以准备脚踏实地带着问题看看源码。\n\n本篇的主角是HashMap,下面会带着问题对源码进行分析。\n\nJava版本是1.8.0_45\n\n#### 目录\n\n* [如何初始化HashMap](#init)\n\n* [如何存储数据](#struct)\n\n* [如何扩容](#resize)\n\n* [如何遍历](#iter)\n\n* [ConcurrentModificationException](#ConcurrentModificationException)\n\n* [线程不安全体现在哪里](#unsafe)\n\n* [如何保证效率](#effect)\n\n* [tips](#tips)\n\n\n<h2 id=\"init\">如何初始化HashMap</h2>\n\nHashMap提供了四种初始化方法\n\n```\n    /* 使用默认参数构建 */\n    public HashMap();\n\n    /* 指定初始容量 */\n    public HashMap(int initialCapacity)\n\n    /* 指定初始容量和loadFactor */\n    public HashMap(int initialCapacity, float loadFactor);\n\n    /* 从另一个Map赋值构建 */\n    public HashMap(Map<? extends K, ? extends V> m)         \n\n```\n这里目前只讨论第三个构造方法，第一个和第二个与第三个行为相同，第四个方法与putAll方法相同，之后再说。\n###### initialCapacity\n表示初始化时的容量，如果存储的元素达到阈值之后会进行扩容，所以如果明确Map中的元素数量，最好在构造时就把容量调好，默认是16。\n###### loadFactor与threshold\nloadFactor用于描述何时对容器进行扩容和重新Hash的值，默认是0.75。threshold用于表示扩容的阈值，当元素数超过threshold时便进行扩容，loadFactor用于生成threshold和在putAll时使用。第一次生成的threshold=capacity * loadFactor，之后每次扩容 threshold = threshold * 2。\n\n\n\n#### 接下来看看构造方法的实现\n\n\n\n```\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n    \n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n\n```\n\ntableSizeFor方法会返回比cap大的最小的2的指数。\n\n\n\n<h2 id=\"struct\">如何存储数据</h2>\n\n\n\n先看看HashMap的数据如何储存。\n\n\n\n#### 存储的实现\n\n\n\nHashMap的数据存储在Node<K,V>[]中。\n\n``` \n    interface Entry<K,V> {\n        K getKey();\n        V getValue();\n        V setValue(V value);\n        boolean equals(Object o);\n        int hashCode();\n    }\n    \n    static class Node<K,V> implements Map.Entry<K,V> {\n        /* 为hash(key)的值 */\n        final int hash;        \n        final K key;\n        V value;\n        Node<K,V> next;\n\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        /* 方法的实现比较直白，就省略了。 */\n\n    }\n    \n    \n    transient Node<K,V>[] table;\n        \n    /* 元素数 */\n    transient int size;\n        \n    /* modify count在遍历的时候会说明 */    \n    transient int modCount;\n    \n    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n\n```\n\n\n\n值得注意的是Node<K,V>的属性next,也就是说Node其实是一个链表的节点，用于解决hash冲突的情况，hash相同的Node放在同一个链表里。\n\n#### put\n\n\n\n接下来看看如何put。\n\n\n\n```\n    public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n    \n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        \n        /* 当table还没有初始化的时候使用resize()，进行内存分配。*/\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        \n        /*\n            n为tab.length也就是capacity，capacity是2的指数，会在resize的时候说到。\n            (n - 1) & hash 把 hash均匀映射到了0至n-1的区间内，当Node[i]为空时直接创建Node。\n        */  \n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            /* Node[i]上已经存在了Node。 */\n            Node<K,V> e; K k;\n            /* e用于表示被覆盖的Node，如果节点是key与当前key相等，给e赋值，之后覆盖 */\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                /* 如果Node是TreeNode，即使用红黑树存储数据，调用红黑树的put方法*/\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                /* p.key不与key相等，使用链表的next判断剩下的节点。 */\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        /* 判断如果没有响应的key,把生成的新Node放在链表最后。 */\n                        p.next = newNode(hash, key, value, null);\n                        \n                        /* TREEIFY_THRESHOLD = 8，如果链表中的Node 数大于8，把Node链表转换成由TreeNode组成的红黑树。 */\n                        if (binCount >= TREEIFY_THRESHOLD - 1)\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    /* 找到相同的key，break */\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    /* 循环条件 */\n                    p = e;\n                }\n            }\n            \n            /* e不为空，覆盖 */\n            if (e != null) {\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        /* 如果元素数量超过阈值，则进行扩容 */\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n\n```\n\nTreeNode是在1.8中新引入的，为了解决hash冲突造成的查询效率降低。当链表里的元素数超过8之后，会把Node数组table中的节点替换成TreeNode,TreeNode组成了一颗红黑树，可以保证在hash冲突的情况下提供O(logN)的查询。需要注意的是红黑树中需要比较两个TreeNode的key来生成树，key的类型需要实现Comparable，否则会影响查询性能。1.8以后的存储结构图如下：\n\n\n{% asset_img HashMap_Node_1_8.jpeg 1.8下HashMap的Node示意图%}\n\n\n#### get\n\n\n```\n    public V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n    \n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            if (first.hash == hash &&\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                /* TreeNode使用getTreeNode方法 */\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n\n```\n比较易懂，会根据是Node还是TreeNode分别不同的策略来寻找。\n\n<h2 id=\"resize\">如何扩容</h2>\n\n扩容需要调用resize()方法，resize方法会把容量扩容为原来的一倍，把原来的所有Node重新通过(capacity-1) & hash(key) 计算新的位置并赋值，重新构造newTable[]。所以扩容是一个比较消耗性能的行为，要减少扩容的次数。\n\n```\n    final Node<K,V>[] resize() {\n    \n        /* 根据是初始化表的情况还是扩容的情况来计算新的capacity和新的threshold */\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        \n        /* 遍历原来的table,生成新的节点放入新的table */\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n\n```\n\n<h2 id=\"iter\">如何遍历</h2>\nHashMap的遍历主要使用以下三个方法，keySet()，values()，entrySet()。这里只看entrySet，keySet与values的实现与enterySet差别不大。\n\n```\n\n    transient Set<Map.Entry<K,V>> entrySet;\n\n    final class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n        public final int size()                 { return size; }\n        /* 会清除整个HashMap */\n        public final void clear()               { HashMap.this.clear(); }\n        public final Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n        public final boolean contains(Object o) {\n            if (!(o instanceof Map.Entry))\n                return false;\n            Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n            Object key = e.getKey();\n            Node<K,V> candidate = getNode(hash(key), key);\n            return candidate != null && candidate.equals(e);\n        }\n        /* remove会删除真实的Node */\n        public final boolean remove(Object o) {\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n                Object key = e.getKey();\n                Object value = e.getValue();\n                return removeNode(hash(key), key, value, true, true) != null;\n            }\n            return false;\n        }\n        /* Stream并行操作使用的方法，这里不讨论了 */\n        public final Spliterator<Map.Entry<K,V>> spliterator() {\n            return new EntrySpliterator<>(HashMap.this, 0, -1, 0, 0);\n        }\n        public final void forEach(Consumer<? super Map.Entry<K,V>> action) {\n            Node<K,V>[] tab;\n            if (action == null)\n                throw new NullPointerException();\n            if (size > 0 && (tab = table) != null) {\n                int mc = modCount;\n                for (int i = 0; i < tab.length; ++i) {\n                    for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                        action.accept(e);\n                }\n                if (modCount != mc)\n                    throw new ConcurrentModificationException();\n            }\n        }\n    }\n    \n    final class EntryIterator extends HashIterator\n        implements Iterator<Map.Entry<K,V>> {\n        public final Map.Entry<K,V> next() { return nextNode(); }\n    }\n\n    abstract class HashIterator {\n        Node<K,V> next;        // next entry to return\n        Node<K,V> current;     // current entry\n        int expectedModCount;  // for fast-fail\n        int index;             // current slot\n\n        HashIterator() {\n            expectedModCount = modCount;\n            Node<K,V>[] t = table;\n            current = next = null;\n            index = 0;\n            if (t != null && size > 0) { // advance to first entry\n                do {} while (index < t.length && (next = t[index++]) == null);\n            }\n        }\n\n        public final boolean hasNext() {\n            return next != null;\n        }\n\n        /* 按照table[]的顺序遍历，优先遍历Node的next节点。\n        final Node<K,V> nextNode() {\n            Node<K,V>[] t;\n            Node<K,V> e = next;\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            if (e == null)\n                throw new NoSuchElementException();\n            if ((next = (current = e).next) == null && (t = table) != null) {\n                do {} while (index < t.length && (next = t[index++]) == null);\n            }\n            return e;\n        }\n\n        public final void remove() {\n            Node<K,V> p = current;\n            if (p == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            current = null;\n            K key = p.key;\n            removeNode(hash(key), key, null, false, false);\n            expectedModCount = modCount;\n        }\n    }\n\n```\nentrySet返回的Set其实是个视图，所有对entrySet的操作会反映到实际的table上。值得注意的是代码中经常会出现类似\n```\n    if (modCount != mc)\n        throw new ConcurrentModificationException();\n    \n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n```\n这样的代码，当modCount和expectModeCount不相等时会抛出ConcurrentModificationException。\n\n<h2 id=\"ConcurrentModificationException\">ConcurrentModificationException</h2>\nConcurrentModificationException是一个在遍历时没写好就会出现的异常，这个异常描述的是，在遍历过程中，元素发生了添加、删除、覆盖。判断是否抛出ConcurrentModificationException是依据modCount是否等于expectModCount来判断的。首先看看哪些地方会抛出ConcurrentModificationException。\n\n```\n    Map<K,V> hashMap = new HashMap<>();\n    hashMap.keySet().forEach();\n    hashMap.values().forEach();\n    hashMap.entrySet().forEach();\n    hashMap.forEach();\n    hashMap.replaceAll();\n    \n    hashMap.keySet().iterator().next();\n    hashMap.values().iterator().next();\n    hashMap.entrySet().iterator().next();\n       \n    hashMap.keySet().iterator().remove();\n    hashMap.values().iterator().remove();\n    hashMap.entrySet().iterator().remove();\n    \n    /* 同样没有考虑并行stream的操作 */\n```\n其中后六个迭代器的方法其实是从他们的基类HashIterator的继承来的。\n\n接下来看看哪些方法会修改modCount的值。\n\n```\n    Map<K,V> hashMap = new HashMap<>();\n    hashMap.put();\n    hashMap.putAll();\n    hashMap.putIfAbsent();\n    \n    hashMap.remove();\n    hashMap.keySet().remove();\n    hashMap.entrySet().remove();\n    hashMap.compute();\n    hashMap.computeIfPresent();\n    hashMap.computeIfAbsent();\n    \n    /* 上面也提到了这些方法，这些方法先判断是否抛出异常，然后删除修改modCount，最后更新expectModCount，所以在单线程下这些方法可以拿来在循环中使用*/\n    hashMap.keySet().iterator().remove();\n    hashMap.values().iterator().remove();\n    hashMap.entrySet().iterator().remove();\n    \n    hashmap.clear();\n    \n    /* 同样没有考虑并行stream的操作 */\n```\n在遍历过程中不要使用上面这些方法，否则会抛出ConcurrentModificationException。下面看看为什么要有ConcurrentModificationException。\n\n```\n    Map<K,V> hashMap = new HashMap<>();\n    K k = new K();\n    /* 正确的遍历删除 */\n    Iterator<K> it =map.keySet().iterator();\n    while(it.hasNext()){\n        K key = it.next();\n        if(key==K) {\n            it.remove();\n        }\n    }\n    \n    /* 正确的遍历删除的简写 */\n    map.keySet().removeIf(key -> key == K);\n    \n    /* 更加函数式风格的写法，这个在多线程环境也是OK的，因为没有修改而是复制后赋值。不可变大法好 */\n    map = map.entrySet().stream()\n                .filter(entry -> entry.getKey() ==K)\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    \n    /* 会抛异常的遍历删除 */\n    for(Map.Entry<K,V> entry : map.entrySet()){\n            if(entry.getKey()==K){\n                map.remove(entry.getKey());\n       }\n    }\n        \n```\n在单线程环境下看一下，会抛异常的遍历删除，如果去掉ConcurrentModificationException会导致什么问题?\n在单线程的情况下，如果不存在hash冲突并不会存在什么问题，此时遍历的话会顺序寻找table[]中的下一个非空的元素。但如果存在hash冲突的话，就会产生各种各样的问题了。\n\n先考虑链表的情况：\n\n```\n\n假设hash为K的Node是链表，链表里有两个Node，分别为N1和N2，目前遍历到N1，即Current=N1，Next=N2，N1.next=N2。\n\n此时删除N2，N1.next=null，此时N2还被Next引用，继续调用迭代器的Next就可以遍历到一个已经被删除的Node。\n\n此时删除N1，实际上并不会产生什么问题，因为已经遍历过N1，\n\n```\n\n然后考虑红黑树的情况：\n\n```\n情况就非常多变了，删除节点时红黑树为了保证其性质，会进行翻转，改变节点之间的关系。遍历就很容易出现问题了。\n```\n\n在多线程环境下，就会有无数种方法出现ConcurrentModificationException，同时还会存在很多其他问题，说到底HashMap就不是应用于多线程的。\n \n<h2 id=\"unsafe\">线程不安全体现在哪里</h2>\n\nHashMap的所有方法都没有加锁，多线程使用且不只读会出现各种各样问题，例如：\n\n- 两个线程同时put，(capacity-1) & hash(key)值相等，同时判断当前数组位置为空，预料加入两个Node结果最后只加进去一个。\n\n- 一个线程put，另一个线程remove，i=(capacity-1) & hash(key)值相等，remove线程决定给table[i]制空后，put添加在table[i]的链表后面。预计table[i]存在一个Node结果一个Node也没有。\n \n要解决线程安全问题有几个思路：\n\n- 使用同步容器，Collections.synchronizedMap(map)\n\n- 使用并发容器，ConcurrentHashMap\n\n- 保证只读，修改的时候复制一份，在副本上修改，然后使用副本代替原件，保证不存在中间状态，同时使用volatile。\n\n三种方式各有各的优劣：\n\n- 读场景多，写场景非常少，元素少的时候，第三种方式是可以考虑的选择，因为对比前两个查询不需要额外的操作可以保证效率最高。\n\n- 元素多，写场景不太少且线程不多的情况下，第二种方式非常不错，第一种方法每一个操作都需要加锁，效率不高，第三个方法复制时间太长，可能导致数据更新慢。\n\n- 元素多，写场景不太少且线程很多的情况下，第一种方法才有些优势，第二种方法使用了乐观锁，在大量线程去征用的时候可能会长时间阻塞，第一种方法完全同步，在获取锁的速度上优于第二种。\n\n总的来说，在大多数多线程场景下ConcurrentHashMap都可以提供不错的性能，首选。\n\n<h2 id=\"effect\">如何保证效率</h2>\n\n- 通过hash()映射key到数组，实现O(1)查询\n\n- 通过链表或是红黑树解决hash冲突，实现最差O(k)查询（k为同一数组位置下的元素数）\n\n- 通过扩容减少hash冲突的几率\n\n<h2 id=\"tips\">tips</h2>\n\n\n- 初始化时尽量设置好容量\n\n- key的类型要实现好hashCode和equals方法\n\n- key的类型要实现好Comparable借口\n\n- 注意循环内的操作，避免ConcurrentModificationException\n\n- 不要在多线程下使用\n\n\n\n\n\n\n","source":"_posts/脚踏实地-HashMap.md","raw":"---\ntitle: 脚踏实地-HashMap\ndate: 2018-08-01 00:15:06\ntags:\n- Java\n- HashMap\ncategories:\n- 脚踏实地\n\n---\n\n<i>带着问题分析HashMap源码，包括：如何初始化，基础操作的实现，扩容，遍历等。</i>\n\n<!-- more -->\n\n## 前言\n\n\n\n前些日子找工作面试的时候暴露了我的一个问题，有些问题知其然而不知其所以然。例如：我们都知道HashMap不是线程安全的，那么多线程中使用HashMap会产生什么问题？ConcurrentHashMap是线程安全的，为了线程安全做了哪些牺牲，有什么局限性？无法回答这些问题的原因是，没有看源码或是看源码时没有进行思考，所以准备脚踏实地带着问题看看源码。\n\n本篇的主角是HashMap,下面会带着问题对源码进行分析。\n\nJava版本是1.8.0_45\n\n#### 目录\n\n* [如何初始化HashMap](#init)\n\n* [如何存储数据](#struct)\n\n* [如何扩容](#resize)\n\n* [如何遍历](#iter)\n\n* [ConcurrentModificationException](#ConcurrentModificationException)\n\n* [线程不安全体现在哪里](#unsafe)\n\n* [如何保证效率](#effect)\n\n* [tips](#tips)\n\n\n<h2 id=\"init\">如何初始化HashMap</h2>\n\nHashMap提供了四种初始化方法\n\n```\n    /* 使用默认参数构建 */\n    public HashMap();\n\n    /* 指定初始容量 */\n    public HashMap(int initialCapacity)\n\n    /* 指定初始容量和loadFactor */\n    public HashMap(int initialCapacity, float loadFactor);\n\n    /* 从另一个Map赋值构建 */\n    public HashMap(Map<? extends K, ? extends V> m)         \n\n```\n这里目前只讨论第三个构造方法，第一个和第二个与第三个行为相同，第四个方法与putAll方法相同，之后再说。\n###### initialCapacity\n表示初始化时的容量，如果存储的元素达到阈值之后会进行扩容，所以如果明确Map中的元素数量，最好在构造时就把容量调好，默认是16。\n###### loadFactor与threshold\nloadFactor用于描述何时对容器进行扩容和重新Hash的值，默认是0.75。threshold用于表示扩容的阈值，当元素数超过threshold时便进行扩容，loadFactor用于生成threshold和在putAll时使用。第一次生成的threshold=capacity * loadFactor，之后每次扩容 threshold = threshold * 2。\n\n\n\n#### 接下来看看构造方法的实现\n\n\n\n```\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n    \n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n\n```\n\ntableSizeFor方法会返回比cap大的最小的2的指数。\n\n\n\n<h2 id=\"struct\">如何存储数据</h2>\n\n\n\n先看看HashMap的数据如何储存。\n\n\n\n#### 存储的实现\n\n\n\nHashMap的数据存储在Node<K,V>[]中。\n\n``` \n    interface Entry<K,V> {\n        K getKey();\n        V getValue();\n        V setValue(V value);\n        boolean equals(Object o);\n        int hashCode();\n    }\n    \n    static class Node<K,V> implements Map.Entry<K,V> {\n        /* 为hash(key)的值 */\n        final int hash;        \n        final K key;\n        V value;\n        Node<K,V> next;\n\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        /* 方法的实现比较直白，就省略了。 */\n\n    }\n    \n    \n    transient Node<K,V>[] table;\n        \n    /* 元素数 */\n    transient int size;\n        \n    /* modify count在遍历的时候会说明 */    \n    transient int modCount;\n    \n    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n\n```\n\n\n\n值得注意的是Node<K,V>的属性next,也就是说Node其实是一个链表的节点，用于解决hash冲突的情况，hash相同的Node放在同一个链表里。\n\n#### put\n\n\n\n接下来看看如何put。\n\n\n\n```\n    public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n    \n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        \n        /* 当table还没有初始化的时候使用resize()，进行内存分配。*/\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        \n        /*\n            n为tab.length也就是capacity，capacity是2的指数，会在resize的时候说到。\n            (n - 1) & hash 把 hash均匀映射到了0至n-1的区间内，当Node[i]为空时直接创建Node。\n        */  \n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            /* Node[i]上已经存在了Node。 */\n            Node<K,V> e; K k;\n            /* e用于表示被覆盖的Node，如果节点是key与当前key相等，给e赋值，之后覆盖 */\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                /* 如果Node是TreeNode，即使用红黑树存储数据，调用红黑树的put方法*/\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                /* p.key不与key相等，使用链表的next判断剩下的节点。 */\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        /* 判断如果没有响应的key,把生成的新Node放在链表最后。 */\n                        p.next = newNode(hash, key, value, null);\n                        \n                        /* TREEIFY_THRESHOLD = 8，如果链表中的Node 数大于8，把Node链表转换成由TreeNode组成的红黑树。 */\n                        if (binCount >= TREEIFY_THRESHOLD - 1)\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    /* 找到相同的key，break */\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    /* 循环条件 */\n                    p = e;\n                }\n            }\n            \n            /* e不为空，覆盖 */\n            if (e != null) {\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        /* 如果元素数量超过阈值，则进行扩容 */\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n\n```\n\nTreeNode是在1.8中新引入的，为了解决hash冲突造成的查询效率降低。当链表里的元素数超过8之后，会把Node数组table中的节点替换成TreeNode,TreeNode组成了一颗红黑树，可以保证在hash冲突的情况下提供O(logN)的查询。需要注意的是红黑树中需要比较两个TreeNode的key来生成树，key的类型需要实现Comparable，否则会影响查询性能。1.8以后的存储结构图如下：\n\n\n{% asset_img HashMap_Node_1_8.jpeg 1.8下HashMap的Node示意图%}\n\n\n#### get\n\n\n```\n    public V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n    \n    final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n            if (first.hash == hash &&\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                /* TreeNode使用getTreeNode方法 */\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n\n```\n比较易懂，会根据是Node还是TreeNode分别不同的策略来寻找。\n\n<h2 id=\"resize\">如何扩容</h2>\n\n扩容需要调用resize()方法，resize方法会把容量扩容为原来的一倍，把原来的所有Node重新通过(capacity-1) & hash(key) 计算新的位置并赋值，重新构造newTable[]。所以扩容是一个比较消耗性能的行为，要减少扩容的次数。\n\n```\n    final Node<K,V>[] resize() {\n    \n        /* 根据是初始化表的情况还是扩容的情况来计算新的capacity和新的threshold */\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        \n        /* 遍历原来的table,生成新的节点放入新的table */\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n\n```\n\n<h2 id=\"iter\">如何遍历</h2>\nHashMap的遍历主要使用以下三个方法，keySet()，values()，entrySet()。这里只看entrySet，keySet与values的实现与enterySet差别不大。\n\n```\n\n    transient Set<Map.Entry<K,V>> entrySet;\n\n    final class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n        public final int size()                 { return size; }\n        /* 会清除整个HashMap */\n        public final void clear()               { HashMap.this.clear(); }\n        public final Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n        public final boolean contains(Object o) {\n            if (!(o instanceof Map.Entry))\n                return false;\n            Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n            Object key = e.getKey();\n            Node<K,V> candidate = getNode(hash(key), key);\n            return candidate != null && candidate.equals(e);\n        }\n        /* remove会删除真实的Node */\n        public final boolean remove(Object o) {\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n                Object key = e.getKey();\n                Object value = e.getValue();\n                return removeNode(hash(key), key, value, true, true) != null;\n            }\n            return false;\n        }\n        /* Stream并行操作使用的方法，这里不讨论了 */\n        public final Spliterator<Map.Entry<K,V>> spliterator() {\n            return new EntrySpliterator<>(HashMap.this, 0, -1, 0, 0);\n        }\n        public final void forEach(Consumer<? super Map.Entry<K,V>> action) {\n            Node<K,V>[] tab;\n            if (action == null)\n                throw new NullPointerException();\n            if (size > 0 && (tab = table) != null) {\n                int mc = modCount;\n                for (int i = 0; i < tab.length; ++i) {\n                    for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                        action.accept(e);\n                }\n                if (modCount != mc)\n                    throw new ConcurrentModificationException();\n            }\n        }\n    }\n    \n    final class EntryIterator extends HashIterator\n        implements Iterator<Map.Entry<K,V>> {\n        public final Map.Entry<K,V> next() { return nextNode(); }\n    }\n\n    abstract class HashIterator {\n        Node<K,V> next;        // next entry to return\n        Node<K,V> current;     // current entry\n        int expectedModCount;  // for fast-fail\n        int index;             // current slot\n\n        HashIterator() {\n            expectedModCount = modCount;\n            Node<K,V>[] t = table;\n            current = next = null;\n            index = 0;\n            if (t != null && size > 0) { // advance to first entry\n                do {} while (index < t.length && (next = t[index++]) == null);\n            }\n        }\n\n        public final boolean hasNext() {\n            return next != null;\n        }\n\n        /* 按照table[]的顺序遍历，优先遍历Node的next节点。\n        final Node<K,V> nextNode() {\n            Node<K,V>[] t;\n            Node<K,V> e = next;\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            if (e == null)\n                throw new NoSuchElementException();\n            if ((next = (current = e).next) == null && (t = table) != null) {\n                do {} while (index < t.length && (next = t[index++]) == null);\n            }\n            return e;\n        }\n\n        public final void remove() {\n            Node<K,V> p = current;\n            if (p == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            current = null;\n            K key = p.key;\n            removeNode(hash(key), key, null, false, false);\n            expectedModCount = modCount;\n        }\n    }\n\n```\nentrySet返回的Set其实是个视图，所有对entrySet的操作会反映到实际的table上。值得注意的是代码中经常会出现类似\n```\n    if (modCount != mc)\n        throw new ConcurrentModificationException();\n    \n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n```\n这样的代码，当modCount和expectModeCount不相等时会抛出ConcurrentModificationException。\n\n<h2 id=\"ConcurrentModificationException\">ConcurrentModificationException</h2>\nConcurrentModificationException是一个在遍历时没写好就会出现的异常，这个异常描述的是，在遍历过程中，元素发生了添加、删除、覆盖。判断是否抛出ConcurrentModificationException是依据modCount是否等于expectModCount来判断的。首先看看哪些地方会抛出ConcurrentModificationException。\n\n```\n    Map<K,V> hashMap = new HashMap<>();\n    hashMap.keySet().forEach();\n    hashMap.values().forEach();\n    hashMap.entrySet().forEach();\n    hashMap.forEach();\n    hashMap.replaceAll();\n    \n    hashMap.keySet().iterator().next();\n    hashMap.values().iterator().next();\n    hashMap.entrySet().iterator().next();\n       \n    hashMap.keySet().iterator().remove();\n    hashMap.values().iterator().remove();\n    hashMap.entrySet().iterator().remove();\n    \n    /* 同样没有考虑并行stream的操作 */\n```\n其中后六个迭代器的方法其实是从他们的基类HashIterator的继承来的。\n\n接下来看看哪些方法会修改modCount的值。\n\n```\n    Map<K,V> hashMap = new HashMap<>();\n    hashMap.put();\n    hashMap.putAll();\n    hashMap.putIfAbsent();\n    \n    hashMap.remove();\n    hashMap.keySet().remove();\n    hashMap.entrySet().remove();\n    hashMap.compute();\n    hashMap.computeIfPresent();\n    hashMap.computeIfAbsent();\n    \n    /* 上面也提到了这些方法，这些方法先判断是否抛出异常，然后删除修改modCount，最后更新expectModCount，所以在单线程下这些方法可以拿来在循环中使用*/\n    hashMap.keySet().iterator().remove();\n    hashMap.values().iterator().remove();\n    hashMap.entrySet().iterator().remove();\n    \n    hashmap.clear();\n    \n    /* 同样没有考虑并行stream的操作 */\n```\n在遍历过程中不要使用上面这些方法，否则会抛出ConcurrentModificationException。下面看看为什么要有ConcurrentModificationException。\n\n```\n    Map<K,V> hashMap = new HashMap<>();\n    K k = new K();\n    /* 正确的遍历删除 */\n    Iterator<K> it =map.keySet().iterator();\n    while(it.hasNext()){\n        K key = it.next();\n        if(key==K) {\n            it.remove();\n        }\n    }\n    \n    /* 正确的遍历删除的简写 */\n    map.keySet().removeIf(key -> key == K);\n    \n    /* 更加函数式风格的写法，这个在多线程环境也是OK的，因为没有修改而是复制后赋值。不可变大法好 */\n    map = map.entrySet().stream()\n                .filter(entry -> entry.getKey() ==K)\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    \n    /* 会抛异常的遍历删除 */\n    for(Map.Entry<K,V> entry : map.entrySet()){\n            if(entry.getKey()==K){\n                map.remove(entry.getKey());\n       }\n    }\n        \n```\n在单线程环境下看一下，会抛异常的遍历删除，如果去掉ConcurrentModificationException会导致什么问题?\n在单线程的情况下，如果不存在hash冲突并不会存在什么问题，此时遍历的话会顺序寻找table[]中的下一个非空的元素。但如果存在hash冲突的话，就会产生各种各样的问题了。\n\n先考虑链表的情况：\n\n```\n\n假设hash为K的Node是链表，链表里有两个Node，分别为N1和N2，目前遍历到N1，即Current=N1，Next=N2，N1.next=N2。\n\n此时删除N2，N1.next=null，此时N2还被Next引用，继续调用迭代器的Next就可以遍历到一个已经被删除的Node。\n\n此时删除N1，实际上并不会产生什么问题，因为已经遍历过N1，\n\n```\n\n然后考虑红黑树的情况：\n\n```\n情况就非常多变了，删除节点时红黑树为了保证其性质，会进行翻转，改变节点之间的关系。遍历就很容易出现问题了。\n```\n\n在多线程环境下，就会有无数种方法出现ConcurrentModificationException，同时还会存在很多其他问题，说到底HashMap就不是应用于多线程的。\n \n<h2 id=\"unsafe\">线程不安全体现在哪里</h2>\n\nHashMap的所有方法都没有加锁，多线程使用且不只读会出现各种各样问题，例如：\n\n- 两个线程同时put，(capacity-1) & hash(key)值相等，同时判断当前数组位置为空，预料加入两个Node结果最后只加进去一个。\n\n- 一个线程put，另一个线程remove，i=(capacity-1) & hash(key)值相等，remove线程决定给table[i]制空后，put添加在table[i]的链表后面。预计table[i]存在一个Node结果一个Node也没有。\n \n要解决线程安全问题有几个思路：\n\n- 使用同步容器，Collections.synchronizedMap(map)\n\n- 使用并发容器，ConcurrentHashMap\n\n- 保证只读，修改的时候复制一份，在副本上修改，然后使用副本代替原件，保证不存在中间状态，同时使用volatile。\n\n三种方式各有各的优劣：\n\n- 读场景多，写场景非常少，元素少的时候，第三种方式是可以考虑的选择，因为对比前两个查询不需要额外的操作可以保证效率最高。\n\n- 元素多，写场景不太少且线程不多的情况下，第二种方式非常不错，第一种方法每一个操作都需要加锁，效率不高，第三个方法复制时间太长，可能导致数据更新慢。\n\n- 元素多，写场景不太少且线程很多的情况下，第一种方法才有些优势，第二种方法使用了乐观锁，在大量线程去征用的时候可能会长时间阻塞，第一种方法完全同步，在获取锁的速度上优于第二种。\n\n总的来说，在大多数多线程场景下ConcurrentHashMap都可以提供不错的性能，首选。\n\n<h2 id=\"effect\">如何保证效率</h2>\n\n- 通过hash()映射key到数组，实现O(1)查询\n\n- 通过链表或是红黑树解决hash冲突，实现最差O(k)查询（k为同一数组位置下的元素数）\n\n- 通过扩容减少hash冲突的几率\n\n<h2 id=\"tips\">tips</h2>\n\n\n- 初始化时尽量设置好容量\n\n- key的类型要实现好hashCode和equals方法\n\n- key的类型要实现好Comparable借口\n\n- 注意循环内的操作，避免ConcurrentModificationException\n\n- 不要在多线程下使用\n\n\n\n\n\n\n","slug":"脚踏实地-HashMap","published":1,"updated":"2018-08-05T09:54:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkgpmvk900087lcgegm1o68o","content":"<p><i>带着问题分析HashMap源码，包括：如何初始化，基础操作的实现，扩容，遍历等。</i></p>\n<a id=\"more\"></a>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前些日子找工作面试的时候暴露了我的一个问题，有些问题知其然而不知其所以然。例如：我们都知道HashMap不是线程安全的，那么多线程中使用HashMap会产生什么问题？ConcurrentHashMap是线程安全的，为了线程安全做了哪些牺牲，有什么局限性？无法回答这些问题的原因是，没有看源码或是看源码时没有进行思考，所以准备脚踏实地带着问题看看源码。</p>\n<p>本篇的主角是HashMap,下面会带着问题对源码进行分析。</p>\n<p>Java版本是1.8.0_45</p>\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><ul>\n<li><p><a href=\"#init\">如何初始化HashMap</a></p>\n</li>\n<li><p><a href=\"#struct\">如何存储数据</a></p>\n</li>\n<li><p><a href=\"#resize\">如何扩容</a></p>\n</li>\n<li><p><a href=\"#iter\">如何遍历</a></p>\n</li>\n<li><p><a href=\"#ConcurrentModificationException\">ConcurrentModificationException</a></p>\n</li>\n<li><p><a href=\"#unsafe\">线程不安全体现在哪里</a></p>\n</li>\n<li><p><a href=\"#effect\">如何保证效率</a></p>\n</li>\n<li><p><a href=\"#tips\">tips</a></p>\n</li>\n</ul>\n<h2 id=\"init\">如何初始化HashMap</h2>\n\n<p>HashMap提供了四种初始化方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 使用默认参数构建 */</span><br><span class=\"line\">public HashMap();</span><br><span class=\"line\"></span><br><span class=\"line\">/* 指定初始容量 */</span><br><span class=\"line\">public HashMap(int initialCapacity)</span><br><span class=\"line\"></span><br><span class=\"line\">/* 指定初始容量和loadFactor */</span><br><span class=\"line\">public HashMap(int initialCapacity, float loadFactor);</span><br><span class=\"line\"></span><br><span class=\"line\">/* 从另一个Map赋值构建 */</span><br><span class=\"line\">public HashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br></pre></td></tr></table></figure>\n<p>这里目前只讨论第三个构造方法，第一个和第二个与第三个行为相同，第四个方法与putAll方法相同，之后再说。</p>\n<h6 id=\"initialCapacity\"><a href=\"#initialCapacity\" class=\"headerlink\" title=\"initialCapacity\"></a>initialCapacity</h6><p>表示初始化时的容量，如果存储的元素达到阈值之后会进行扩容，所以如果明确Map中的元素数量，最好在构造时就把容量调好，默认是16。</p>\n<h6 id=\"loadFactor与threshold\"><a href=\"#loadFactor与threshold\" class=\"headerlink\" title=\"loadFactor与threshold\"></a>loadFactor与threshold</h6><p>loadFactor用于描述何时对容器进行扩容和重新Hash的值，默认是0.75。threshold用于表示扩容的阈值，当元素数超过threshold时便进行扩容，loadFactor用于生成threshold和在putAll时使用。第一次生成的threshold=capacity <em> loadFactor，之后每次扩容 threshold = threshold </em> 2。</p>\n<h4 id=\"接下来看看构造方法的实现\"><a href=\"#接下来看看构造方法的实现\" class=\"headerlink\" title=\"接下来看看构造方法的实现\"></a>接下来看看构造方法的实现</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class=\"line\">    if (initialCapacity &lt; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    this.loadFactor = loadFactor;</span><br><span class=\"line\">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static final int tableSizeFor(int cap) &#123;</span><br><span class=\"line\">    int n = cap - 1;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 1;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 2;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 4;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 8;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 16;</span><br><span class=\"line\">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>tableSizeFor方法会返回比cap大的最小的2的指数。</p>\n<h2 id=\"struct\">如何存储数据</h2>\n\n\n\n<p>先看看HashMap的数据如何储存。</p>\n<h4 id=\"存储的实现\"><a href=\"#存储的实现\" class=\"headerlink\" title=\"存储的实现\"></a>存储的实现</h4><p>HashMap的数据存储在Node&lt;K,V&gt;[]中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    K getKey();</span><br><span class=\"line\">    V getValue();</span><br><span class=\"line\">    V setValue(V value);</span><br><span class=\"line\">    boolean equals(Object o);</span><br><span class=\"line\">    int hashCode();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    /* 为hash(key)的值 */</span><br><span class=\"line\">    final int hash;        </span><br><span class=\"line\">    final K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        this.hash = hash;</span><br><span class=\"line\">        this.key = key;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 方法的实现比较直白，就省略了。 */</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">transient Node&lt;K,V&gt;[] table;</span><br><span class=\"line\">    </span><br><span class=\"line\">/* 元素数 */</span><br><span class=\"line\">transient int size;</span><br><span class=\"line\">    </span><br><span class=\"line\">/* modify count在遍历的时候会说明 */    </span><br><span class=\"line\">transient int modCount;</span><br><span class=\"line\"></span><br><span class=\"line\">static final int hash(Object key) &#123;</span><br><span class=\"line\">    int h;</span><br><span class=\"line\">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>值得注意的是Node&lt;K,V&gt;的属性next,也就是说Node其实是一个链表的节点，用于解决hash冲突的情况，hash相同的Node放在同一个链表里。</p>\n<h4 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h4><p>接下来看看如何put。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public V put(K key, V value) &#123;</span><br><span class=\"line\">    return putVal(hash(key), key, value, false, true);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class=\"line\">               boolean evict) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /* 当table还没有初始化的时候使用resize()，进行内存分配。*/</span><br><span class=\"line\">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">        n为tab.length也就是capacity，capacity是2的指数，会在resize的时候说到。</span><br><span class=\"line\">        (n - 1) &amp; hash 把 hash均匀映射到了0至n-1的区间内，当Node[i]为空时直接创建Node。</span><br><span class=\"line\">    */  </span><br><span class=\"line\">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, null);</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        /* Node[i]上已经存在了Node。 */</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        /* e用于表示被覆盖的Node，如果节点是key与当前key相等，给e赋值，之后覆盖 */</span><br><span class=\"line\">        if (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        else if (p instanceof TreeNode)</span><br><span class=\"line\">            /* 如果Node是TreeNode，即使用红黑树存储数据，调用红黑树的put方法*/</span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            /* p.key不与key相等，使用链表的next判断剩下的节点。 */</span><br><span class=\"line\">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class=\"line\">                if ((e = p.next) == null) &#123;</span><br><span class=\"line\">                    /* 判断如果没有响应的key,把生成的新Node放在链表最后。 */</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, null);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    /* TREEIFY_THRESHOLD = 8，如果链表中的Node 数大于8，把Node链表转换成由TreeNode组成的红黑树。 */</span><br><span class=\"line\">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                /* 找到相同的key，break */</span><br><span class=\"line\">                if (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                /* 循环条件 */</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        /* e不为空，覆盖 */</span><br><span class=\"line\">        if (e != null) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            if (!onlyIfAbsent || oldValue == null)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            return oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    /* 如果元素数量超过阈值，则进行扩容 */</span><br><span class=\"line\">    if (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TreeNode是在1.8中新引入的，为了解决hash冲突造成的查询效率降低。当链表里的元素数超过8之后，会把Node数组table中的节点替换成TreeNode,TreeNode组成了一颗红黑树，可以保证在hash冲突的情况下提供O(logN)的查询。需要注意的是红黑树中需要比较两个TreeNode的key来生成树，key的类型需要实现Comparable，否则会影响查询性能。1.8以后的存储结构图如下：</p>\n<img src=\"/2018/08/01/脚踏实地-HashMap/HashMap_Node_1_8.jpeg\" title=\"1.8下HashMap的Node示意图\">\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public V get(Object key) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class=\"line\">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class=\"line\">        if (first.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            return first;</span><br><span class=\"line\">        if ((e = first.next) != null) &#123;</span><br><span class=\"line\">            /* TreeNode使用getTreeNode方法 */</span><br><span class=\"line\">            if (first instanceof TreeNode)</span><br><span class=\"line\">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            do &#123;</span><br><span class=\"line\">                if (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    return e;</span><br><span class=\"line\">            &#125; while ((e = e.next) != null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比较易懂，会根据是Node还是TreeNode分别不同的策略来寻找。</p>\n<h2 id=\"resize\">如何扩容</h2>\n\n<p>扩容需要调用resize()方法，resize方法会把容量扩容为原来的一倍，把原来的所有Node重新通过(capacity-1) &amp; hash(key) 计算新的位置并赋值，重新构造newTable[]。所以扩容是一个比较消耗性能的行为，要减少扩容的次数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 根据是初始化表的情况还是扩容的情况来计算新的capacity和新的threshold */</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class=\"line\">    int oldThr = threshold;</span><br><span class=\"line\">    int newCap, newThr = 0;</span><br><span class=\"line\">    if (oldCap &gt; 0) &#123;</span><br><span class=\"line\">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            return oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (newThr == 0) &#123;</span><br><span class=\"line\">        float ft = (float)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (int)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /* 遍历原来的table,生成新的节点放入新的table */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    if (oldTab != null) &#123;</span><br><span class=\"line\">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            if ((e = oldTab[j]) != null) &#123;</span><br><span class=\"line\">                oldTab[j] = null;</span><br><span class=\"line\">                if (e.next == null)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class=\"line\">                else if (e instanceof TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class=\"line\">                else &#123; // preserve order</span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    do &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class=\"line\">                            if (loTail == null)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            else</span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        else &#123;</span><br><span class=\"line\">                            if (hiTail == null)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            else</span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; while ((e = next) != null);</span><br><span class=\"line\">                    if (loTail != null) &#123;</span><br><span class=\"line\">                        loTail.next = null;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    if (hiTail != null) &#123;</span><br><span class=\"line\">                        hiTail.next = null;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"iter\">如何遍历</h2><br>HashMap的遍历主要使用以下三个方法，keySet()，values()，entrySet()。这里只看entrySet，keySet与values的实现与enterySet差别不大。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class=\"line\"></span><br><span class=\"line\">final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class=\"line\">    public final int size()                 &#123; return size; &#125;</span><br><span class=\"line\">    /* 会清除整个HashMap */</span><br><span class=\"line\">    public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class=\"line\">    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class=\"line\">        return new EntryIterator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public final boolean contains(Object o) &#123;</span><br><span class=\"line\">        if (!(o instanceof Map.Entry))</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class=\"line\">        Object key = e.getKey();</span><br><span class=\"line\">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class=\"line\">        return candidate != null &amp;&amp; candidate.equals(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /* remove会删除真实的Node */</span><br><span class=\"line\">    public final boolean remove(Object o) &#123;</span><br><span class=\"line\">        if (o instanceof Map.Entry) &#123;</span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class=\"line\">            Object key = e.getKey();</span><br><span class=\"line\">            Object value = e.getValue();</span><br><span class=\"line\">            return removeNode(hash(key), key, value, true, true) != null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /* Stream并行操作使用的方法，这里不讨论了 */</span><br><span class=\"line\">    public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class=\"line\">        return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab;</span><br><span class=\"line\">        if (action == null)</span><br><span class=\"line\">            throw new NullPointerException();</span><br><span class=\"line\">        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class=\"line\">            int mc = modCount;</span><br><span class=\"line\">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class=\"line\">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class=\"line\">                    action.accept(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (modCount != mc)</span><br><span class=\"line\">                throw new ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">final class EntryIterator extends HashIterator</span><br><span class=\"line\">    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class=\"line\">    public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class HashIterator &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; next;        // next entry to return</span><br><span class=\"line\">    Node&lt;K,V&gt; current;     // current entry</span><br><span class=\"line\">    int expectedModCount;  // for fast-fail</span><br><span class=\"line\">    int index;             // current slot</span><br><span class=\"line\"></span><br><span class=\"line\">    HashIterator() &#123;</span><br><span class=\"line\">        expectedModCount = modCount;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] t = table;</span><br><span class=\"line\">        current = next = null;</span><br><span class=\"line\">        index = 0;</span><br><span class=\"line\">        if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry</span><br><span class=\"line\">            do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final boolean hasNext() &#123;</span><br><span class=\"line\">        return next != null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 按照table[]的顺序遍历，优先遍历Node的next节点。</span><br><span class=\"line\">    final Node&lt;K,V&gt; nextNode() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] t;</span><br><span class=\"line\">        Node&lt;K,V&gt; e = next;</span><br><span class=\"line\">        if (modCount != expectedModCount)</span><br><span class=\"line\">            throw new ConcurrentModificationException();</span><br><span class=\"line\">        if (e == null)</span><br><span class=\"line\">            throw new NoSuchElementException();</span><br><span class=\"line\">        if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123;</span><br><span class=\"line\">            do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final void remove() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; p = current;</span><br><span class=\"line\">        if (p == null)</span><br><span class=\"line\">            throw new IllegalStateException();</span><br><span class=\"line\">        if (modCount != expectedModCount)</span><br><span class=\"line\">            throw new ConcurrentModificationException();</span><br><span class=\"line\">        current = null;</span><br><span class=\"line\">        K key = p.key;</span><br><span class=\"line\">        removeNode(hash(key), key, null, false, false);</span><br><span class=\"line\">        expectedModCount = modCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>entrySet返回的Set其实是个视图，所有对entrySet的操作会反映到实际的table上。值得注意的是代码中经常会出现类似<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (modCount != mc)</span><br><span class=\"line\">    throw new ConcurrentModificationException();</span><br><span class=\"line\"></span><br><span class=\"line\">if (modCount != expectedModCount)</span><br><span class=\"line\">    throw new ConcurrentModificationException();</span><br></pre></td></tr></table></figure><br><br>这样的代码，当modCount和expectModeCount不相等时会抛出ConcurrentModificationException。<br><br><h2 id=\"ConcurrentModificationException\">ConcurrentModificationException</h2><br>ConcurrentModificationException是一个在遍历时没写好就会出现的异常，这个异常描述的是，在遍历过程中，元素发生了添加、删除、覆盖。判断是否抛出ConcurrentModificationException是依据modCount是否等于expectModCount来判断的。首先看看哪些地方会抛出ConcurrentModificationException。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;K,V&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap.keySet().forEach();</span><br><span class=\"line\">hashMap.values().forEach();</span><br><span class=\"line\">hashMap.entrySet().forEach();</span><br><span class=\"line\">hashMap.forEach();</span><br><span class=\"line\">hashMap.replaceAll();</span><br><span class=\"line\"></span><br><span class=\"line\">hashMap.keySet().iterator().next();</span><br><span class=\"line\">hashMap.values().iterator().next();</span><br><span class=\"line\">hashMap.entrySet().iterator().next();</span><br><span class=\"line\">   </span><br><span class=\"line\">hashMap.keySet().iterator().remove();</span><br><span class=\"line\">hashMap.values().iterator().remove();</span><br><span class=\"line\">hashMap.entrySet().iterator().remove();</span><br><span class=\"line\"></span><br><span class=\"line\">/* 同样没有考虑并行stream的操作 */</span><br></pre></td></tr></table></figure><br><br>其中后六个迭代器的方法其实是从他们的基类HashIterator的继承来的。<br><br>接下来看看哪些方法会修改modCount的值。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;K,V&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap.put();</span><br><span class=\"line\">hashMap.putAll();</span><br><span class=\"line\">hashMap.putIfAbsent();</span><br><span class=\"line\"></span><br><span class=\"line\">hashMap.remove();</span><br><span class=\"line\">hashMap.keySet().remove();</span><br><span class=\"line\">hashMap.entrySet().remove();</span><br><span class=\"line\">hashMap.compute();</span><br><span class=\"line\">hashMap.computeIfPresent();</span><br><span class=\"line\">hashMap.computeIfAbsent();</span><br><span class=\"line\"></span><br><span class=\"line\">/* 上面也提到了这些方法，这些方法先判断是否抛出异常，然后删除修改modCount，最后更新expectModCount，所以在单线程下这些方法可以拿来在循环中使用*/</span><br><span class=\"line\">hashMap.keySet().iterator().remove();</span><br><span class=\"line\">hashMap.values().iterator().remove();</span><br><span class=\"line\">hashMap.entrySet().iterator().remove();</span><br><span class=\"line\"></span><br><span class=\"line\">hashmap.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">/* 同样没有考虑并行stream的操作 */</span><br></pre></td></tr></table></figure><br><br>在遍历过程中不要使用上面这些方法，否则会抛出ConcurrentModificationException。下面看看为什么要有ConcurrentModificationException。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;K,V&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">K k = new K();</span><br><span class=\"line\">/* 正确的遍历删除 */</span><br><span class=\"line\">Iterator&lt;K&gt; it =map.keySet().iterator();</span><br><span class=\"line\">while(it.hasNext())&#123;</span><br><span class=\"line\">    K key = it.next();</span><br><span class=\"line\">    if(key==K) &#123;</span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 正确的遍历删除的简写 */</span><br><span class=\"line\">map.keySet().removeIf(key -&gt; key == K);</span><br><span class=\"line\"></span><br><span class=\"line\">/* 更加函数式风格的写法，这个在多线程环境也是OK的，因为没有修改而是复制后赋值。不可变大法好 */</span><br><span class=\"line\">map = map.entrySet().stream()</span><br><span class=\"line\">            .filter(entry -&gt; entry.getKey() ==K)</span><br><span class=\"line\">            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class=\"line\"></span><br><span class=\"line\">/* 会抛异常的遍历删除 */</span><br><span class=\"line\">for(Map.Entry&lt;K,V&gt; entry : map.entrySet())&#123;</span><br><span class=\"line\">        if(entry.getKey()==K)&#123;</span><br><span class=\"line\">            map.remove(entry.getKey());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>在单线程环境下看一下，会抛异常的遍历删除，如果去掉ConcurrentModificationException会导致什么问题?<br>在单线程的情况下，如果不存在hash冲突并不会存在什么问题，此时遍历的话会顺序寻找table[]中的下一个非空的元素。但如果存在hash冲突的话，就会产生各种各样的问题了。<br><br>先考虑链表的情况：<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">假设hash为K的Node是链表，链表里有两个Node，分别为N1和N2，目前遍历到N1，即Current=N1，Next=N2，N1.next=N2。</span><br><span class=\"line\"></span><br><span class=\"line\">此时删除N2，N1.next=null，此时N2还被Next引用，继续调用迭代器的Next就可以遍历到一个已经被删除的Node。</span><br><span class=\"line\"></span><br><span class=\"line\">此时删除N1，实际上并不会产生什么问题，因为已经遍历过N1，</span><br></pre></td></tr></table></figure><br><br>然后考虑红黑树的情况：<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">情况就非常多变了，删除节点时红黑树为了保证其性质，会进行翻转，改变节点之间的关系。遍历就很容易出现问题了。</span><br></pre></td></tr></table></figure><br><br>在多线程环境下，就会有无数种方法出现ConcurrentModificationException，同时还会存在很多其他问题，说到底HashMap就不是应用于多线程的。<br><br><h2 id=\"unsafe\">线程不安全体现在哪里</h2>\n\n<p>HashMap的所有方法都没有加锁，多线程使用且不只读会出现各种各样问题，例如：</p>\n<ul>\n<li><p>两个线程同时put，(capacity-1) &amp; hash(key)值相等，同时判断当前数组位置为空，预料加入两个Node结果最后只加进去一个。</p>\n</li>\n<li><p>一个线程put，另一个线程remove，i=(capacity-1) &amp; hash(key)值相等，remove线程决定给table[i]制空后，put添加在table[i]的链表后面。预计table[i]存在一个Node结果一个Node也没有。</p>\n</li>\n</ul>\n<p>要解决线程安全问题有几个思路：</p>\n<ul>\n<li><p>使用同步容器，Collections.synchronizedMap(map)</p>\n</li>\n<li><p>使用并发容器，ConcurrentHashMap</p>\n</li>\n<li><p>保证只读，修改的时候复制一份，在副本上修改，然后使用副本代替原件，保证不存在中间状态，同时使用volatile。</p>\n</li>\n</ul>\n<p>三种方式各有各的优劣：</p>\n<ul>\n<li><p>读场景多，写场景非常少，元素少的时候，第三种方式是可以考虑的选择，因为对比前两个查询不需要额外的操作可以保证效率最高。</p>\n</li>\n<li><p>元素多，写场景不太少且线程不多的情况下，第二种方式非常不错，第一种方法每一个操作都需要加锁，效率不高，第三个方法复制时间太长，可能导致数据更新慢。</p>\n</li>\n<li><p>元素多，写场景不太少且线程很多的情况下，第一种方法才有些优势，第二种方法使用了乐观锁，在大量线程去征用的时候可能会长时间阻塞，第一种方法完全同步，在获取锁的速度上优于第二种。</p>\n</li>\n</ul>\n<p>总的来说，在大多数多线程场景下ConcurrentHashMap都可以提供不错的性能，首选。</p>\n<h2 id=\"effect\">如何保证效率</h2>\n\n<ul>\n<li><p>通过hash()映射key到数组，实现O(1)查询</p>\n</li>\n<li><p>通过链表或是红黑树解决hash冲突，实现最差O(k)查询（k为同一数组位置下的元素数）</p>\n</li>\n<li><p>通过扩容减少hash冲突的几率</p>\n</li>\n</ul>\n<h2 id=\"tips\">tips</h2>\n\n\n<ul>\n<li><p>初始化时尽量设置好容量</p>\n</li>\n<li><p>key的类型要实现好hashCode和equals方法</p>\n</li>\n<li><p>key的类型要实现好Comparable借口</p>\n</li>\n<li><p>注意循环内的操作，避免ConcurrentModificationException</p>\n</li>\n<li><p>不要在多线程下使用</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><i>带着问题分析HashMap源码，包括：如何初始化，基础操作的实现，扩容，遍历等。</i></p>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前些日子找工作面试的时候暴露了我的一个问题，有些问题知其然而不知其所以然。例如：我们都知道HashMap不是线程安全的，那么多线程中使用HashMap会产生什么问题？ConcurrentHashMap是线程安全的，为了线程安全做了哪些牺牲，有什么局限性？无法回答这些问题的原因是，没有看源码或是看源码时没有进行思考，所以准备脚踏实地带着问题看看源码。</p>\n<p>本篇的主角是HashMap,下面会带着问题对源码进行分析。</p>\n<p>Java版本是1.8.0_45</p>\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><ul>\n<li><p><a href=\"#init\">如何初始化HashMap</a></p>\n</li>\n<li><p><a href=\"#struct\">如何存储数据</a></p>\n</li>\n<li><p><a href=\"#resize\">如何扩容</a></p>\n</li>\n<li><p><a href=\"#iter\">如何遍历</a></p>\n</li>\n<li><p><a href=\"#ConcurrentModificationException\">ConcurrentModificationException</a></p>\n</li>\n<li><p><a href=\"#unsafe\">线程不安全体现在哪里</a></p>\n</li>\n<li><p><a href=\"#effect\">如何保证效率</a></p>\n</li>\n<li><p><a href=\"#tips\">tips</a></p>\n</li>\n</ul>\n<h2 id=\"init\">如何初始化HashMap</h2>\n\n<p>HashMap提供了四种初始化方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 使用默认参数构建 */</span><br><span class=\"line\">public HashMap();</span><br><span class=\"line\"></span><br><span class=\"line\">/* 指定初始容量 */</span><br><span class=\"line\">public HashMap(int initialCapacity)</span><br><span class=\"line\"></span><br><span class=\"line\">/* 指定初始容量和loadFactor */</span><br><span class=\"line\">public HashMap(int initialCapacity, float loadFactor);</span><br><span class=\"line\"></span><br><span class=\"line\">/* 从另一个Map赋值构建 */</span><br><span class=\"line\">public HashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br></pre></td></tr></table></figure>\n<p>这里目前只讨论第三个构造方法，第一个和第二个与第三个行为相同，第四个方法与putAll方法相同，之后再说。</p>\n<h6 id=\"initialCapacity\"><a href=\"#initialCapacity\" class=\"headerlink\" title=\"initialCapacity\"></a>initialCapacity</h6><p>表示初始化时的容量，如果存储的元素达到阈值之后会进行扩容，所以如果明确Map中的元素数量，最好在构造时就把容量调好，默认是16。</p>\n<h6 id=\"loadFactor与threshold\"><a href=\"#loadFactor与threshold\" class=\"headerlink\" title=\"loadFactor与threshold\"></a>loadFactor与threshold</h6><p>loadFactor用于描述何时对容器进行扩容和重新Hash的值，默认是0.75。threshold用于表示扩容的阈值，当元素数超过threshold时便进行扩容，loadFactor用于生成threshold和在putAll时使用。第一次生成的threshold=capacity <em> loadFactor，之后每次扩容 threshold = threshold </em> 2。</p>\n<h4 id=\"接下来看看构造方法的实现\"><a href=\"#接下来看看构造方法的实现\" class=\"headerlink\" title=\"接下来看看构造方法的实现\"></a>接下来看看构造方法的实现</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class=\"line\">    if (initialCapacity &lt; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    this.loadFactor = loadFactor;</span><br><span class=\"line\">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static final int tableSizeFor(int cap) &#123;</span><br><span class=\"line\">    int n = cap - 1;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 1;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 2;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 4;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 8;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 16;</span><br><span class=\"line\">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>tableSizeFor方法会返回比cap大的最小的2的指数。</p>\n<h2 id=\"struct\">如何存储数据</h2>\n\n\n\n<p>先看看HashMap的数据如何储存。</p>\n<h4 id=\"存储的实现\"><a href=\"#存储的实现\" class=\"headerlink\" title=\"存储的实现\"></a>存储的实现</h4><p>HashMap的数据存储在Node&lt;K,V&gt;[]中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    K getKey();</span><br><span class=\"line\">    V getValue();</span><br><span class=\"line\">    V setValue(V value);</span><br><span class=\"line\">    boolean equals(Object o);</span><br><span class=\"line\">    int hashCode();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    /* 为hash(key)的值 */</span><br><span class=\"line\">    final int hash;        </span><br><span class=\"line\">    final K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        this.hash = hash;</span><br><span class=\"line\">        this.key = key;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 方法的实现比较直白，就省略了。 */</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">transient Node&lt;K,V&gt;[] table;</span><br><span class=\"line\">    </span><br><span class=\"line\">/* 元素数 */</span><br><span class=\"line\">transient int size;</span><br><span class=\"line\">    </span><br><span class=\"line\">/* modify count在遍历的时候会说明 */    </span><br><span class=\"line\">transient int modCount;</span><br><span class=\"line\"></span><br><span class=\"line\">static final int hash(Object key) &#123;</span><br><span class=\"line\">    int h;</span><br><span class=\"line\">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>值得注意的是Node&lt;K,V&gt;的属性next,也就是说Node其实是一个链表的节点，用于解决hash冲突的情况，hash相同的Node放在同一个链表里。</p>\n<h4 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h4><p>接下来看看如何put。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public V put(K key, V value) &#123;</span><br><span class=\"line\">    return putVal(hash(key), key, value, false, true);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class=\"line\">               boolean evict) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /* 当table还没有初始化的时候使用resize()，进行内存分配。*/</span><br><span class=\"line\">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">        n为tab.length也就是capacity，capacity是2的指数，会在resize的时候说到。</span><br><span class=\"line\">        (n - 1) &amp; hash 把 hash均匀映射到了0至n-1的区间内，当Node[i]为空时直接创建Node。</span><br><span class=\"line\">    */  </span><br><span class=\"line\">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, null);</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        /* Node[i]上已经存在了Node。 */</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        /* e用于表示被覆盖的Node，如果节点是key与当前key相等，给e赋值，之后覆盖 */</span><br><span class=\"line\">        if (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        else if (p instanceof TreeNode)</span><br><span class=\"line\">            /* 如果Node是TreeNode，即使用红黑树存储数据，调用红黑树的put方法*/</span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            /* p.key不与key相等，使用链表的next判断剩下的节点。 */</span><br><span class=\"line\">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class=\"line\">                if ((e = p.next) == null) &#123;</span><br><span class=\"line\">                    /* 判断如果没有响应的key,把生成的新Node放在链表最后。 */</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, null);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    /* TREEIFY_THRESHOLD = 8，如果链表中的Node 数大于8，把Node链表转换成由TreeNode组成的红黑树。 */</span><br><span class=\"line\">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                /* 找到相同的key，break */</span><br><span class=\"line\">                if (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                /* 循环条件 */</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        /* e不为空，覆盖 */</span><br><span class=\"line\">        if (e != null) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            if (!onlyIfAbsent || oldValue == null)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            return oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    /* 如果元素数量超过阈值，则进行扩容 */</span><br><span class=\"line\">    if (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TreeNode是在1.8中新引入的，为了解决hash冲突造成的查询效率降低。当链表里的元素数超过8之后，会把Node数组table中的节点替换成TreeNode,TreeNode组成了一颗红黑树，可以保证在hash冲突的情况下提供O(logN)的查询。需要注意的是红黑树中需要比较两个TreeNode的key来生成树，key的类型需要实现Comparable，否则会影响查询性能。1.8以后的存储结构图如下：</p>\n<img src=\"/2018/08/01/脚踏实地-HashMap/HashMap_Node_1_8.jpeg\" title=\"1.8下HashMap的Node示意图\">\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public V get(Object key) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class=\"line\">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class=\"line\">        if (first.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            return first;</span><br><span class=\"line\">        if ((e = first.next) != null) &#123;</span><br><span class=\"line\">            /* TreeNode使用getTreeNode方法 */</span><br><span class=\"line\">            if (first instanceof TreeNode)</span><br><span class=\"line\">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            do &#123;</span><br><span class=\"line\">                if (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    return e;</span><br><span class=\"line\">            &#125; while ((e = e.next) != null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比较易懂，会根据是Node还是TreeNode分别不同的策略来寻找。</p>\n<h2 id=\"resize\">如何扩容</h2>\n\n<p>扩容需要调用resize()方法，resize方法会把容量扩容为原来的一倍，把原来的所有Node重新通过(capacity-1) &amp; hash(key) 计算新的位置并赋值，重新构造newTable[]。所以扩容是一个比较消耗性能的行为，要减少扩容的次数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 根据是初始化表的情况还是扩容的情况来计算新的capacity和新的threshold */</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class=\"line\">    int oldThr = threshold;</span><br><span class=\"line\">    int newCap, newThr = 0;</span><br><span class=\"line\">    if (oldCap &gt; 0) &#123;</span><br><span class=\"line\">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            return oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (newThr == 0) &#123;</span><br><span class=\"line\">        float ft = (float)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (int)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /* 遍历原来的table,生成新的节点放入新的table */</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    if (oldTab != null) &#123;</span><br><span class=\"line\">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            if ((e = oldTab[j]) != null) &#123;</span><br><span class=\"line\">                oldTab[j] = null;</span><br><span class=\"line\">                if (e.next == null)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class=\"line\">                else if (e instanceof TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class=\"line\">                else &#123; // preserve order</span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    do &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class=\"line\">                            if (loTail == null)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            else</span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        else &#123;</span><br><span class=\"line\">                            if (hiTail == null)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            else</span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; while ((e = next) != null);</span><br><span class=\"line\">                    if (loTail != null) &#123;</span><br><span class=\"line\">                        loTail.next = null;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    if (hiTail != null) &#123;</span><br><span class=\"line\">                        hiTail.next = null;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"iter\">如何遍历</h2><br>HashMap的遍历主要使用以下三个方法，keySet()，values()，entrySet()。这里只看entrySet，keySet与values的实现与enterySet差别不大。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class=\"line\"></span><br><span class=\"line\">final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class=\"line\">    public final int size()                 &#123; return size; &#125;</span><br><span class=\"line\">    /* 会清除整个HashMap */</span><br><span class=\"line\">    public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class=\"line\">    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class=\"line\">        return new EntryIterator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public final boolean contains(Object o) &#123;</span><br><span class=\"line\">        if (!(o instanceof Map.Entry))</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class=\"line\">        Object key = e.getKey();</span><br><span class=\"line\">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class=\"line\">        return candidate != null &amp;&amp; candidate.equals(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /* remove会删除真实的Node */</span><br><span class=\"line\">    public final boolean remove(Object o) &#123;</span><br><span class=\"line\">        if (o instanceof Map.Entry) &#123;</span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class=\"line\">            Object key = e.getKey();</span><br><span class=\"line\">            Object value = e.getValue();</span><br><span class=\"line\">            return removeNode(hash(key), key, value, true, true) != null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /* Stream并行操作使用的方法，这里不讨论了 */</span><br><span class=\"line\">    public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class=\"line\">        return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab;</span><br><span class=\"line\">        if (action == null)</span><br><span class=\"line\">            throw new NullPointerException();</span><br><span class=\"line\">        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class=\"line\">            int mc = modCount;</span><br><span class=\"line\">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class=\"line\">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class=\"line\">                    action.accept(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (modCount != mc)</span><br><span class=\"line\">                throw new ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">final class EntryIterator extends HashIterator</span><br><span class=\"line\">    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class=\"line\">    public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class HashIterator &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; next;        // next entry to return</span><br><span class=\"line\">    Node&lt;K,V&gt; current;     // current entry</span><br><span class=\"line\">    int expectedModCount;  // for fast-fail</span><br><span class=\"line\">    int index;             // current slot</span><br><span class=\"line\"></span><br><span class=\"line\">    HashIterator() &#123;</span><br><span class=\"line\">        expectedModCount = modCount;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] t = table;</span><br><span class=\"line\">        current = next = null;</span><br><span class=\"line\">        index = 0;</span><br><span class=\"line\">        if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry</span><br><span class=\"line\">            do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final boolean hasNext() &#123;</span><br><span class=\"line\">        return next != null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 按照table[]的顺序遍历，优先遍历Node的next节点。</span><br><span class=\"line\">    final Node&lt;K,V&gt; nextNode() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] t;</span><br><span class=\"line\">        Node&lt;K,V&gt; e = next;</span><br><span class=\"line\">        if (modCount != expectedModCount)</span><br><span class=\"line\">            throw new ConcurrentModificationException();</span><br><span class=\"line\">        if (e == null)</span><br><span class=\"line\">            throw new NoSuchElementException();</span><br><span class=\"line\">        if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123;</span><br><span class=\"line\">            do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final void remove() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; p = current;</span><br><span class=\"line\">        if (p == null)</span><br><span class=\"line\">            throw new IllegalStateException();</span><br><span class=\"line\">        if (modCount != expectedModCount)</span><br><span class=\"line\">            throw new ConcurrentModificationException();</span><br><span class=\"line\">        current = null;</span><br><span class=\"line\">        K key = p.key;</span><br><span class=\"line\">        removeNode(hash(key), key, null, false, false);</span><br><span class=\"line\">        expectedModCount = modCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>entrySet返回的Set其实是个视图，所有对entrySet的操作会反映到实际的table上。值得注意的是代码中经常会出现类似<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (modCount != mc)</span><br><span class=\"line\">    throw new ConcurrentModificationException();</span><br><span class=\"line\"></span><br><span class=\"line\">if (modCount != expectedModCount)</span><br><span class=\"line\">    throw new ConcurrentModificationException();</span><br></pre></td></tr></table></figure><br><br>这样的代码，当modCount和expectModeCount不相等时会抛出ConcurrentModificationException。<br><br><h2 id=\"ConcurrentModificationException\">ConcurrentModificationException</h2><br>ConcurrentModificationException是一个在遍历时没写好就会出现的异常，这个异常描述的是，在遍历过程中，元素发生了添加、删除、覆盖。判断是否抛出ConcurrentModificationException是依据modCount是否等于expectModCount来判断的。首先看看哪些地方会抛出ConcurrentModificationException。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;K,V&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap.keySet().forEach();</span><br><span class=\"line\">hashMap.values().forEach();</span><br><span class=\"line\">hashMap.entrySet().forEach();</span><br><span class=\"line\">hashMap.forEach();</span><br><span class=\"line\">hashMap.replaceAll();</span><br><span class=\"line\"></span><br><span class=\"line\">hashMap.keySet().iterator().next();</span><br><span class=\"line\">hashMap.values().iterator().next();</span><br><span class=\"line\">hashMap.entrySet().iterator().next();</span><br><span class=\"line\">   </span><br><span class=\"line\">hashMap.keySet().iterator().remove();</span><br><span class=\"line\">hashMap.values().iterator().remove();</span><br><span class=\"line\">hashMap.entrySet().iterator().remove();</span><br><span class=\"line\"></span><br><span class=\"line\">/* 同样没有考虑并行stream的操作 */</span><br></pre></td></tr></table></figure><br><br>其中后六个迭代器的方法其实是从他们的基类HashIterator的继承来的。<br><br>接下来看看哪些方法会修改modCount的值。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;K,V&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap.put();</span><br><span class=\"line\">hashMap.putAll();</span><br><span class=\"line\">hashMap.putIfAbsent();</span><br><span class=\"line\"></span><br><span class=\"line\">hashMap.remove();</span><br><span class=\"line\">hashMap.keySet().remove();</span><br><span class=\"line\">hashMap.entrySet().remove();</span><br><span class=\"line\">hashMap.compute();</span><br><span class=\"line\">hashMap.computeIfPresent();</span><br><span class=\"line\">hashMap.computeIfAbsent();</span><br><span class=\"line\"></span><br><span class=\"line\">/* 上面也提到了这些方法，这些方法先判断是否抛出异常，然后删除修改modCount，最后更新expectModCount，所以在单线程下这些方法可以拿来在循环中使用*/</span><br><span class=\"line\">hashMap.keySet().iterator().remove();</span><br><span class=\"line\">hashMap.values().iterator().remove();</span><br><span class=\"line\">hashMap.entrySet().iterator().remove();</span><br><span class=\"line\"></span><br><span class=\"line\">hashmap.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">/* 同样没有考虑并行stream的操作 */</span><br></pre></td></tr></table></figure><br><br>在遍历过程中不要使用上面这些方法，否则会抛出ConcurrentModificationException。下面看看为什么要有ConcurrentModificationException。<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;K,V&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">K k = new K();</span><br><span class=\"line\">/* 正确的遍历删除 */</span><br><span class=\"line\">Iterator&lt;K&gt; it =map.keySet().iterator();</span><br><span class=\"line\">while(it.hasNext())&#123;</span><br><span class=\"line\">    K key = it.next();</span><br><span class=\"line\">    if(key==K) &#123;</span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 正确的遍历删除的简写 */</span><br><span class=\"line\">map.keySet().removeIf(key -&gt; key == K);</span><br><span class=\"line\"></span><br><span class=\"line\">/* 更加函数式风格的写法，这个在多线程环境也是OK的，因为没有修改而是复制后赋值。不可变大法好 */</span><br><span class=\"line\">map = map.entrySet().stream()</span><br><span class=\"line\">            .filter(entry -&gt; entry.getKey() ==K)</span><br><span class=\"line\">            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class=\"line\"></span><br><span class=\"line\">/* 会抛异常的遍历删除 */</span><br><span class=\"line\">for(Map.Entry&lt;K,V&gt; entry : map.entrySet())&#123;</span><br><span class=\"line\">        if(entry.getKey()==K)&#123;</span><br><span class=\"line\">            map.remove(entry.getKey());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>在单线程环境下看一下，会抛异常的遍历删除，如果去掉ConcurrentModificationException会导致什么问题?<br>在单线程的情况下，如果不存在hash冲突并不会存在什么问题，此时遍历的话会顺序寻找table[]中的下一个非空的元素。但如果存在hash冲突的话，就会产生各种各样的问题了。<br><br>先考虑链表的情况：<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">假设hash为K的Node是链表，链表里有两个Node，分别为N1和N2，目前遍历到N1，即Current=N1，Next=N2，N1.next=N2。</span><br><span class=\"line\"></span><br><span class=\"line\">此时删除N2，N1.next=null，此时N2还被Next引用，继续调用迭代器的Next就可以遍历到一个已经被删除的Node。</span><br><span class=\"line\"></span><br><span class=\"line\">此时删除N1，实际上并不会产生什么问题，因为已经遍历过N1，</span><br></pre></td></tr></table></figure><br><br>然后考虑红黑树的情况：<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">情况就非常多变了，删除节点时红黑树为了保证其性质，会进行翻转，改变节点之间的关系。遍历就很容易出现问题了。</span><br></pre></td></tr></table></figure><br><br>在多线程环境下，就会有无数种方法出现ConcurrentModificationException，同时还会存在很多其他问题，说到底HashMap就不是应用于多线程的。<br><br><h2 id=\"unsafe\">线程不安全体现在哪里</h2>\n\n<p>HashMap的所有方法都没有加锁，多线程使用且不只读会出现各种各样问题，例如：</p>\n<ul>\n<li><p>两个线程同时put，(capacity-1) &amp; hash(key)值相等，同时判断当前数组位置为空，预料加入两个Node结果最后只加进去一个。</p>\n</li>\n<li><p>一个线程put，另一个线程remove，i=(capacity-1) &amp; hash(key)值相等，remove线程决定给table[i]制空后，put添加在table[i]的链表后面。预计table[i]存在一个Node结果一个Node也没有。</p>\n</li>\n</ul>\n<p>要解决线程安全问题有几个思路：</p>\n<ul>\n<li><p>使用同步容器，Collections.synchronizedMap(map)</p>\n</li>\n<li><p>使用并发容器，ConcurrentHashMap</p>\n</li>\n<li><p>保证只读，修改的时候复制一份，在副本上修改，然后使用副本代替原件，保证不存在中间状态，同时使用volatile。</p>\n</li>\n</ul>\n<p>三种方式各有各的优劣：</p>\n<ul>\n<li><p>读场景多，写场景非常少，元素少的时候，第三种方式是可以考虑的选择，因为对比前两个查询不需要额外的操作可以保证效率最高。</p>\n</li>\n<li><p>元素多，写场景不太少且线程不多的情况下，第二种方式非常不错，第一种方法每一个操作都需要加锁，效率不高，第三个方法复制时间太长，可能导致数据更新慢。</p>\n</li>\n<li><p>元素多，写场景不太少且线程很多的情况下，第一种方法才有些优势，第二种方法使用了乐观锁，在大量线程去征用的时候可能会长时间阻塞，第一种方法完全同步，在获取锁的速度上优于第二种。</p>\n</li>\n</ul>\n<p>总的来说，在大多数多线程场景下ConcurrentHashMap都可以提供不错的性能，首选。</p>\n<h2 id=\"effect\">如何保证效率</h2>\n\n<ul>\n<li><p>通过hash()映射key到数组，实现O(1)查询</p>\n</li>\n<li><p>通过链表或是红黑树解决hash冲突，实现最差O(k)查询（k为同一数组位置下的元素数）</p>\n</li>\n<li><p>通过扩容减少hash冲突的几率</p>\n</li>\n</ul>\n<h2 id=\"tips\">tips</h2>\n\n\n<ul>\n<li><p>初始化时尽量设置好容量</p>\n</li>\n<li><p>key的类型要实现好hashCode和equals方法</p>\n</li>\n<li><p>key的类型要实现好Comparable借口</p>\n</li>\n<li><p>注意循环内的操作，避免ConcurrentModificationException</p>\n</li>\n<li><p>不要在多线程下使用</p>\n</li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/脚踏实地-HashMap/HashMap_Node_1_7.jpeg","slug":"HashMap_Node_1_7.jpeg","post":"cjkgpmvk900087lcgegm1o68o","modified":0,"renderable":0},{"_id":"source/_posts/脚踏实地-HashMap/HashMap_Node_1_8.jpeg","slug":"HashMap_Node_1_8.jpeg","post":"cjkgpmvk900087lcgegm1o68o","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjkgpmvjs00017lcgsyrwn7x5","category_id":"cjkgpmvjv00027lcgyqx2ewoy","_id":"cjkgpmvjy00057lcggwrkmb86"},{"post_id":"cjkgpmvk900087lcgegm1o68o","category_id":"cjkgpmvkb00097lcgyrwttnhg","_id":"cjkgpmvkc000c7lcglhmlgy4n"}],"PostTag":[{"post_id":"cjkgpmvjs00017lcgsyrwn7x5","tag_id":"cjkgpmvjw00037lcgooey6yr9","_id":"cjkgpmvjz00067lcgoq9j05ky"},{"post_id":"cjkgpmvjs00017lcgsyrwn7x5","tag_id":"cjkgpmvjx00047lcgmv9oaboo","_id":"cjkgpmvjz00077lcg41c7upuf"},{"post_id":"cjkgpmvk900087lcgegm1o68o","tag_id":"cjkgpmvkb000a7lcg9yur5mam","_id":"cjkgpmvkc000d7lcgwaped70d"},{"post_id":"cjkgpmvk900087lcgegm1o68o","tag_id":"cjkgpmvkc000b7lcgxg2an164","_id":"cjkgpmvkc000e7lcg8ve19965"}],"Tag":[{"name":"SpringCloud","_id":"cjkgpmvjw00037lcgooey6yr9"},{"name":"SpringCloudConfig","_id":"cjkgpmvjx00047lcgmv9oaboo"},{"name":"Java","_id":"cjkgpmvkb000a7lcg9yur5mam"},{"name":"HashMap","_id":"cjkgpmvkc000b7lcgxg2an164"}]}}